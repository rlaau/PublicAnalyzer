<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Rope Graph Viewer</title>
  <style>
    html,body{height:100%;margin:0}
    #container{position:absolute;inset:0}
    #hud{position:absolute;top:10px;left:10px;z-index:10;background:rgba(255,255,255,.92);padding:8px 10px;border-radius:10px;font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Noto Sans,Arial;box-shadow:0 2px 10px rgba(0,0,0,.08)}
    #hud code{padding:2px 6px;background:#eee;border-radius:6px}
    #diag{position:absolute;right:10px;bottom:10px;z-index:10;background:rgba(0,0,0,.6);color:#fff;padding:8px 10px;border-radius:8px;font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Noto Sans,Arial;white-space:pre-wrap;max-width:40vw}
  </style>
  <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.min.js"></script>
  <script src="https://unpkg.com/sigma@2.4.0/build/sigma.min.js"></script>
</head>
<body>
  <div id="hud"><strong>Rope Graph Viewer</strong>
    <div>nodes: <code id="ncount">0</code> | edges: <code id="ecount">0</code></div>
  </div>
  <div id="container"></div>
  <div id="diag"></div>

<script>
(function(){
  const diag = document.getElementById('diag');
  const log  = (...a)=>{ console.log(...a); diag.textContent += a.map(x=>typeof x==='string'?x:JSON.stringify(x)).join(' ')+'\\n'; };

  const SigmaCtor = (window && (window.Sigma || (window.sigma && window.sigma.Sigma))) || null;
  const Graph     = (window && window.graphology && window.graphology.Graph) ? window.graphology.Graph : null;

  if (!SigmaCtor) { diag.textContent = 'sigma UMD not found\\n'; }
  if (!Graph)     { diag.textContent += 'graphology UMD not found\\n'; }

  let GRAPH = null, RENDERER = null, DATA = null;

  function colorHsl(h,s,l){ return 'hsl('+h+','+s+'%,'+l+'%)'; }
  function ropeColor(id){ const h=(id*89+45)%360, s=60+(id%3)*10, l=35+(id%4)*5; return colorHsl(h,s,l); }
  function traitColor(code){ const h=(code*137)%360; return colorHsl(h,70,45); }
  function labelColor(bg){
    const m=/hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/.exec(bg); const l=m?+m[3]:50; return l>55?'#222':'#fff';
  }

  function buildGraphFromData(data){
    DATA = data;
    const G = new Graph({ type:'undirected', multi:true }); // multi-edge 허용
    // nodes
    (data.nodes||[]).forEach((n,i)=>{
      const c = n.color || (n.ropeId ? ropeColor(n.ropeId) : '#888');
      G.addNode(n.id, {
        label: n.label || n.id,
        size: Math.max(4, Math.min(16, n.size||8)),
        color: c,
        labelColor: labelColor(c),
        x: Math.cos(2*Math.PI*i/Math.max(1,(data.nodes||[]).length))*100,
        y: Math.sin(2*Math.PI*i/Math.max(1,(data.nodes||[]).length))*100
      });
    });

    // edges (쌍별 카운팅으로 시각적 분산값 기록)
    const pairCounts = Object.create(null); // "lo|hi" -> count
    const eseen = new Set();
    (data.edges||[]).forEach((e)=>{
      if (eseen.has(e.id)) return; eseen.add(e.id);
      const src = e.source, dst = e.target;
      if (!G.hasNode(src)) { const c='#888'; G.addNode(src,{label:src,size:6,color:c,labelColor:labelColor(c)}); }
      if (!G.hasNode(dst)) { const c='#888'; G.addNode(dst,{label:dst,size:6,color:c,labelColor:labelColor(c)}); }

      const lo = src < dst ? src : dst;
      const hi = src < dst ? dst : src;
      const k  = (pairCounts[lo+'|'+hi] = (pairCounts[lo+'|'+hi]||0)+1);
      const curveness = 0.15 + (k-1)*0.08; // (UMD 에선 실제 커브 렌더는 보류됨; 값은 보관)

      G.addEdgeWithKey(e.id, src, dst, {
        size: Math.max(1, Math.min(5, e.weight||1)),
        color: e.color || traitColor(e.traitCode||0),
        traitCode: e.traitCode, traitName: e.traitName, traitId: e.traitId, lastSeen: e.lastSeen||0,
        curveness: curveness
      });
    });
    return G;
  }

  function mount(G){
    const container = document.getElementById('container');
    if (RENDERER) { RENDERER.kill(); RENDERER=null; }
    GRAPH = G;
    RENDERER = new SigmaCtor(GRAPH, container, {
      renderLabels: true, labelDensity: 0.85, labelSize: 10,
      labelColor: { color: 'data(labelColor)' }
    });
    document.getElementById('ncount').textContent = String(GRAPH.order);
    document.getElementById('ecount').textContent = String(GRAPH.size);

    // hover: node
    RENDERER.on('enterNode', ({node})=>{
      const a = GRAPH.getNodeAttributes(node);
      window.parent && window.parent.postMessage({type:'node-hover', payload:{ id: node, label: a.label, color: a.color }}, '*');
    });
    RENDERER.on('leaveNode', ()=>{ window.parent && window.parent.postMessage({type:'node-hover', payload:null}, '*'); });

    // hover: edge
    RENDERER.on('enterEdge', ({edge})=>{
      const a = GRAPH.getEdgeAttributes(edge);
      window.parent && window.parent.postMessage({type:'edge-hover', payload:{
        id: edge, traitCode: a.traitCode||0, traitName: a.traitName||'', traitId: a.traitId||0, lastSeen: a.lastSeen||0
      }}, '*');
    });
    RENDERER.on('leaveEdge', ()=>{ window.parent && window.parent.postMessage({type:'edge-hover', payload:null}, '*'); });

    // click: node
    RENDERER.on('clickNode', ({node})=>{
      window.parent && window.parent.postMessage({type:'node-click', payload:{ id: node }}, '*');
    });
  }

  // local 1-hop (테스트용, 서버 붙이면 parent가 직접 JSON 호출)
  function localOneHop(vid){
    if (!DATA) return null;
    const nbr = new Set(); const edges=[]; const nodes=[];
    (DATA.edges||[]).forEach(e=>{ if (e.source===vid){nbr.add(e.target);edges.push(e)} else if(e.target===vid){nbr.add(e.source);edges.push(e)} });
    (DATA.nodes||[]).forEach(n=>{ if(n.id===vid || nbr.has(n.id)) nodes.push(n) });
    return {
      meta:{generatedAt:Math.floor(Date.now()/1000), graphType:'expanded', startNode:vid, nodeCount:nodes.length, edgeCount:edges.length},
      nodes, edges, legend: DATA.legend||{traits:{}, ropes:{}}
    };
  }

  window.addEventListener('message', (ev)=>{
    const msg = ev.data||{};
    if (msg.type==='load-graph'){
      try { const g=buildGraphFromData(msg.payload); mount(g);
        window.parent && window.parent.postMessage({type:'child-ready', payload:{ok:true}}, '*');
      } catch(e){ log('load-graph error', e); window.parent && window.parent.postMessage({type:'child-ready', payload:{ok:false, error:String(e)}}, '*'); }
    } else if (msg.type==='expand'){
      const v = msg.payload && msg.payload.vertexId;
      if (!v) return;
      const inc = localOneHop(v);
      window.parent && window.parent.postMessage({type:'expand-result', payload:inc}, '*');
    } else if (msg.type==='apply-graph'){
      const g = buildGraphFromData(msg.payload);
      mount(g);
    }
  });

  window.parent && window.parent.postMessage({type:'child-mounted'}, '*');
})();
</script>
</body></html>