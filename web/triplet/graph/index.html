<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>RopeDB Visualizer</title>
<style>
  *{box-sizing:border-box}
  html,body{margin:0;height:100vh;scrollbar-gutter:stable both-edges}
  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    display:grid;grid-template-columns:60% 40%;grid-template-rows:60% 40%;
    gap:10px;background:#f5f5f5;padding:10px
  }
  #graph,#search,#legend,#info{background:#fff;border-radius:10px;box-shadow:0 2px 10px rgba(0,0,0,.08);overflow:hidden}
  #graph{grid-column:1;grid-row:1;overflow:hidden;overscroll-behavior:contain}
  #search{grid-column:2;grid-row:1;padding:16px}
  #info{grid-column:1;grid-row:2;padding:16px}
  #legend{grid-column:2;grid-row:2;padding:16px}
  #f{width:100%;height:100%;border:0;overflow:hidden;display:block}
  .sec h3{margin:0 0 10px 0;font-size:14px;color:#333}
  .row{margin-bottom:12px}
  input[type=text]{width:100%;padding:10px;border:1px solid #ddd;border-radius:8px;font-size:13px}
  button{margin-top:6px;width:100%;padding:10px;border:0;border-radius:8px;cursor:pointer;background:#2f6fed;color:#fff;font-weight:600}
  button.green{background:#28a745}
  .legend-item{display:flex;align-items:center;margin-bottom:6px}
  .legend-color{width:16px;height:16px;border-radius:3px;margin-right:8px}
  .kv{font-size:12px;color:#555}.kv b{color:#222}.muted{color:#888;font-size:12px}.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  #info .kv{font-size:15px;font-weight:600;color:#333}
  #info .kv b{color:#111;font-weight:700}
  #info .muted{color:#666;font-size:13px;font-weight:500}
  #info .mono{font-weight:600}
  #info .sec h3{font-size:16px;font-weight:700;color:#222}
  
  /* ì•Œë¦¼ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ */
  .notification {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(47, 111, 237, 0.95);
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    font-size: 14px;
    font-weight: 600;
    z-index: 1000;
    animation: slideDown 0.3s ease-out;
    max-width: 500px;
  }
  
  @keyframes slideDown {
    from {
      transform: translateX(-50%) translateY(-100%);
      opacity: 0;
    }
    to {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  }
  
  @keyframes slideUp {
    from {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
    to {
      transform: translateX(-50%) translateY(-100%);
      opacity: 0;
    }
  }
  
  .notification.hiding {
    animation: slideUp 0.3s ease-out;
  }
</style>
</head>
<body>
  <section id="graph"><iframe id="f" src="/ui/triplet/graph/frame" scrolling="no"></iframe></section>

  <section id="search" style="max-height: 90vh; overflow-y: auto; padding-right: 8px;">
    <div class="sec">
      <h3>ğŸ” Address Search</h3>
      <div class="row"><input id="addr" type="text" placeholder="0x1234..."/></div>
      <button id="addrBtn">Search Address + 1-hop</button>
    </div>
    <div class="sec" style="margin-top:14px">
      <h3>ğŸ§µ Rope Search</h3>
      <div class="row"><input id="rope" type="text" placeholder="Rope ID (e.g. 1, 2, 3)"/></div>
      <button id="ropeBtn">Search Rope Members + 1-hop</button>
      
      <!-- ë¡œí”„ ì •ë³´ í‘œì‹œ ì˜ì—­ -->
      <div id="ropeInfoPanel" style="margin-top:10px; display:none; padding:8px; background:#f8f9fa; border-radius:6px; border:1px solid #e9ecef;">
        <h4 style="margin:0 0 8px 0; font-size:12px; color:#495057;">ğŸ“‹ Rope Information</h4>
        <div id="ropeInfoContent" class="kv" style="font-size:11px; line-height:1.3;">
          <!-- ë¡œí”„ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
        </div>
      </div>
    </div>
    <div class="sec" style="margin-top:14px">
      <h3>ğŸ”— PolyRope Search</h3>
      <div class="row"><input id="polyAddr1" type="text" placeholder="Address 1: 0x1234..."/></div>
      <div class="row"><input id="polyAddr2" type="text" placeholder="Address 2: 0x5678..."/></div>
      <div class="row"><input id="polyTraitCode" type="text" placeholder="PolyTrait Code (e.g. 100)"/></div>
      <button id="polyRopeBtn">Check PolyRope Connection</button>
      
      <!-- PolyRope ê²€ìƒ‰ ê²°ê³¼ í‘œì‹œ ì˜ì—­ -->
      <div id="polyRopeResultPanel" style="margin-top:10px; display:none; padding:8px; background:#f0f8ff; border-radius:6px; border:1px solid #b3d9ff;">
        <h4 style="margin:0 0 8px 0; font-size:12px; color:#1565c0;">ğŸ” PolyRope Search Result</h4>
        <div id="polyRopeResultContent" class="kv" style="font-size:11px; line-height:1.3;">
          <!-- PolyRope ê²€ìƒ‰ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
        </div>
      </div>
    </div>
    <button id="defBtn" class="green" style="margin-top:14px">ğŸ  Default View</button>
  </section>

  <section id="legend"  style="overflow-y: auto;">
    <div class="sec">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
        <h3 style="margin: 0;">ğŸ¨ Trait Colors</h3>
        <button onclick="recoverTrait()" style="background: #ff9800; color: white; border: none; padding: 3px 6px; border-radius: 3px; font-size: 10px; cursor: pointer;" onmouseover="this.style.background='#f57c00'" onmouseout="this.style.background='#ff9800'">Trait í•´ì œ</button>
      </div>
      <div id="traitLegend"></div>
    </div>
        <div class="sec" style="margin-top:10px">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
        <h3 style="margin: 0;">ğŸ”— PolyTrait Colors</h3>
        <button onclick="recoverPolyTrait()" style="background: #9c27b0; color: white; border: none; padding: 3px 6px; border-radius: 3px; font-size: 10px; cursor: pointer;" onmouseover="this.style.background='#7b1fa2'" onmouseout="this.style.background='#9c27b0'">PolyTrait í•´ì œ</button>
      </div>
      <div id="polyTraitLegend"></div>
    </div>
    <div class="sec" style="margin-top:10px">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
        <h3 style="margin: 0;">ğŸ“‹ Rule Colors</h3>
        <button onclick="recoverRule()" style="background: #2196f3; color: white; border: none; padding: 3px 6px; border-radius: 3px; font-size: 10px; cursor: pointer;" onmouseover="this.style.background='#1976d2'" onmouseout="this.style.background='#2196f3'">Rule í•´ì œ</button>
      </div>
      <div id="ruleLegend"></div>
    </div>
  </section>

  <section id="info" style="overflow-y:auto;">
    <div class="sec">
      <h3>â„¹ï¸ Info</h3>
      <div id="stat" class="kv">
        Nodes: <b id="sn">0</b> | Edges: <b id="se">0</b><br/>
        Type: <b id="st">-</b><br/>
        Start: <span id="ss" class="mono muted">-</span>
      </div>
    </div>
    <div class="sec" style="margin-top:10px">
      <h3>Node</h3>
      <div id="nodeBox" class="kv muted">Hover a nodeâ€¦</div>
    </div>
    <div class="sec" style="margin-top:10px">
      <h3>Edge</h3>
      <div id="edgeBox" class="kv muted">Hover an edgeâ€¦</div>
    </div>
  </section>

<script>
const f = document.getElementById('f');
const sn=document.getElementById('sn'), se=document.getElementById('se'), st=document.getElementById('st'), ss=document.getElementById('ss');
const nodeBox=document.getElementById('nodeBox'), edgeBox=document.getElementById('edgeBox');
let CURRENT = { meta:{}, nodes:[], edges:[], legend:{traits:{}, rules:{}, polyTraits:{}} };

// PolyTrait ê´€ë ¨ ìƒíƒœ ë° ë°ì´í„°
let currentHighlightPolyTrait = null;
let polyTraitLegendData = {};

// Info íŒ¨ë„ ì´ˆê¸°í™” í•¨ìˆ˜
function resetInfoPanel() {
  nodeBox.textContent = 'Hover a nodeâ€¦';
  nodeBox.classList.add('muted');
  edgeBox.textContent = 'Hover an edgeâ€¦';
  edgeBox.classList.add('muted');
}

// ë¡œí”„ ì •ë³´ íŒ¨ë„ ê´€ë ¨ í•¨ìˆ˜ë“¤
function showRopeInfo(ropeInfo) {
  const panel = document.getElementById('ropeInfoPanel');
  const content = document.getElementById('ropeInfoContent');
  
  if (!ropeInfo) {
    panel.style.display = 'none';
    return;
  }
  
  // ì‹œê°„ í¬ë§·íŒ… í•¨ìˆ˜
  const formatTime = (timestamp) => {
    const date = new Date(timestamp * 1000);
    return date.toLocaleString();
  };
  
  // ë©¤ë²„ ì£¼ì†Œë“¤ì„ ì§§ê²Œ í‘œì‹œ
  const formatMembers = (members) => {
    if (!members || members.length === 0) return 'None';
    const shortMembers = members.map(addr => {
      if (addr.length > 13) {
        return addr.substring(0, 6) + '..' + addr.substring(addr.length - 4);
      }
      return addr;
    });
    return shortMembers.join(', ');
  };
  
  let html = '';
  html += '<div><b>ID:</b> ' + (ropeInfo.id || 'N/A') + '</div>';
  html += '<div><b>Trait:</b> ' + (ropeInfo.trait || 'N/A') + ' (' + (ropeInfo.traitName || 'Unknown') + ')</div>';
  html += '<div><b>Size:</b> ' + (ropeInfo.size || 'N/A') + '</div>';
  html += '<div><b>Volume:</b> ' + (ropeInfo.volume || 'N/A') + '</div>';
  html += '<div><b>Last Seen:</b> ' + (ropeInfo.lastSeen ? formatTime(ropeInfo.lastSeen) : 'N/A') + '</div>';
  html += '<div><b>Members:</b><br/><span style="font-family:monospace; font-size:10px;">' + formatMembers(ropeInfo.members) + '</span></div>';
  
  content.innerHTML = html;
  panel.style.display = 'block';
}

function hideRopeInfo() {
  const panel = document.getElementById('ropeInfoPanel');
  panel.style.display = 'none';
}

function loadRopeInfo(ropeId) {
  console.log('Loading rope info for rope:', ropeId);
  
  const url = '/api/triplet/graph/rope-info/' + encodeURIComponent(ropeId);
  
  fetch(url)
    .then(r => r.json())
    .then(ropeInfo => {
      console.log('Rope info loaded:', ropeInfo);
      showRopeInfo(ropeInfo);
    })
    .catch(err => {
      console.error('Failed to load rope info:', err);
      hideRopeInfo();
    });
}

// ì•Œë¦¼ ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜
function showNotification(message, duration = 2000) {
  // ê¸°ì¡´ ì•Œë¦¼ ì œê±°
  const existing = document.querySelector('.notification');
  if (existing) {
    existing.remove();
  }
  
  // ìƒˆ ì•Œë¦¼ ìƒì„±
  const notification = document.createElement('div');
  notification.className = 'notification';
  notification.innerHTML = message;
  document.body.appendChild(notification);
  
  // ì§€ì •ëœ ì‹œê°„ í›„ ì œê±°
  setTimeout(() => {
    notification.classList.add('hiding');
    setTimeout(() => {
      notification.remove();
    }, 300);
  }, duration);
}

function syncStats(g){
  sn.textContent = String(g.meta?.nodeCount || (g.nodes?g.nodes.length:0) || 0);
  se.textContent = String(g.meta?.edgeCount || (g.edges?g.edges.length:0) || 0);
  st.textContent = g.meta?.graphType || '-';
  ss.textContent = g.meta?.startNode || '-';
}
// Rule ìƒ‰ìƒ ìƒì„± í•¨ìˆ˜
function generateRuleColor(ruleId) {
  // Ruleë³„ë¡œ ê³ ìœ í•œ ìƒ‰ìƒ ìƒì„± (íŠ¸ë ˆì´íŠ¸ì™€ ë‹¤ë¥¸ ìƒ‰ìƒ ë²”ìœ„ ì‚¬ìš©)
  const h = (ruleId * 137 + 30) % 360;  // 137ì€ í™©ê¸ˆë¹„ì— ê°€ê¹Œìš´ ì†Œìˆ˜
  const s = 55 + (ruleId % 3) * 10;     // 55-75% ì±„ë„
  const l = 45 + (ruleId % 4) * 5;      // 45-60% ëª…ë„
  return `hsl(${h}, ${s}%, ${l}%)`;
}

// ë²”ë¡€ ë³‘í•© í•¨ìˆ˜: ê¸°ì¡´ ë²”ë¡€ ìƒ‰ìƒì„ ìœ ì§€í•˜ë©´ì„œ ìƒˆë¡œìš´ ë°ì´í„° ì¶”ê°€
function mergeLegends(existingLegend, newLegend) {
  const merged = {
    traits: { ...existingLegend.traits },
    rules: { ...existingLegend.rules }
  };
  
  // ìƒˆë¡œìš´ íŠ¸ë ˆì´íŠ¸ë“¤ ì¶”ê°€ (ìƒ‰ìƒì€ ê¸°ì¡´ ê²ƒ ìš°ì„ )
  if (newLegend.traits) {
    for (const [key, item] of Object.entries(newLegend.traits)) {
      if (!merged.traits[key]) {
        merged.traits[key] = item;
      }
      // ê¸°ì¡´ íŠ¸ë ˆì´íŠ¸ëŠ” ìƒ‰ìƒ ìœ ì§€ (countëŠ” ë‚˜ì¤‘ì— ì¬ê³„ì‚°)
    }
  }
  
  // ìƒˆë¡œìš´ Ruleë“¤ ì¶”ê°€ (ìƒ‰ìƒì€ ê¸°ì¡´ ê²ƒ ìš°ì„ )
  if (newLegend.rules) {
    for (const [key, item] of Object.entries(newLegend.rules)) {
      if (!merged.rules[key]) {
        merged.rules[key] = item;
      }
    }
  }
  
  return merged;
}

// í˜„ì¬ ê·¸ë˜í”„ ìƒíƒœë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë²”ë¡€ ì¹´ìš´íŠ¸ ì¬ê³„ì‚°
function recalculateLegendCounts(legend, nodes, edges) {
  const updated = {
    traits: { ...legend.traits },
    rules: {}
  };
  
  // ëª¨ë“  ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
  Object.keys(updated.traits).forEach(key => {
    updated.traits[key] = { ...updated.traits[key], count: 0 };
  });
  
  // ì—£ì§€ì—ì„œ íŠ¸ë ˆì´íŠ¸ ì¹´ìš´íŠ¸ ê³„ì‚°
  edges.forEach(edge => {
    const traitKey = String(edge.traitCode || 0);
    if (updated.traits[traitKey]) {
      updated.traits[traitKey].count++;
    }
  });
  
  // Rule ë²”ë¡€ ë³´ì¡´ ë° ì¹´ìš´íŠ¸ ê³„ì‚° (ê¸°ì¡´ ìƒ‰ìƒ/ì´ë¦„ ìœ ì§€)
  const ruleCount = {};
  console.log('=== Rule Legend Debug ===');
  console.log(`Total nodes to process: ${nodes.length}`);
  
  // ê¸°ì¡´ Rule ë²”ë¡€ ë³µì‚¬ (ìƒ‰ìƒê³¼ ì´ë¦„ ë³´ì¡´)
  if (legend.rules) {
    Object.keys(legend.rules).forEach(ruleId => {
      updated.rules[ruleId] = { 
        ...legend.rules[ruleId], 
        count: 0 
      };
    });
  }
  
  nodes.forEach((node, index) => {
    console.log(`Node ${index}:`, node.id, 'traits:', node.traits?.length || 0);
    
    // ë…¸ë“œì˜ traitsì—ì„œ ì‹¤ì œ RuleCode ì¶”ì¶œ - ë” ê²¬ê³ í•œ ê²€ì¦
    if (node.traits && Array.isArray(node.traits)) {
      // ê° ë…¸ë“œì— ëŒ€í•´ í•´ë‹¹ ë…¸ë“œê°€ ê°€ì§„ Ruleë“¤ì„ ìˆ˜ì§‘
      const nodeRules = new Set();
      
      node.traits.forEach((trait, traitIndex) => {
        console.log(`  Trait ${traitIndex}:`, trait);
        
        // ruleCode ì†ì„± í™•ì¸ - ë‹¤ì–‘í•œ í˜•íƒœ ì§€ì›
        let ruleCode = null;
        if (trait.ruleCode !== undefined && trait.ruleCode !== null) {
          ruleCode = trait.ruleCode;
        } else if (trait.RuleCode !== undefined && trait.RuleCode !== null) {
          ruleCode = trait.RuleCode;
        } else if (trait.rule_code !== undefined && trait.rule_code !== null) {
          ruleCode = trait.rule_code;
        }
        
        console.log(`    TraitCode: ${trait.traitCode}, RuleCode: ${ruleCode}`);
        
        // ìœ íš¨í•œ ruleCodeì¸ì§€ í™•ì¸ (0ë³´ë‹¤ í¬ê³  ìˆ«ìì—¬ì•¼ í•¨)
        if (ruleCode !== null && ruleCode !== undefined && ruleCode > 0) {
          const numericRuleCode = Number(ruleCode);
          if (!isNaN(numericRuleCode) && numericRuleCode > 0) {
            nodeRules.add(numericRuleCode);
            console.log(`    Added rule: ${numericRuleCode}`);
          } else {
            console.log(`    Invalid rule code: ${ruleCode} (not a positive number)`);
          }
        } else {
          console.log(`    No valid rule code found for trait ${trait.traitCode}`);
        }
      });
      
      console.log(`  Node ${node.id} total unique rules: ${nodeRules.size}`, Array.from(nodeRules));
      
      // ì‹¤ì œ RuleCodeë“¤ì„ ë²”ë¡€ì— ì¶”ê°€ (ê¸°ì¡´ ìƒ‰ìƒ/ì´ë¦„ ìš°ì„ )
      nodeRules.forEach(ruleCode => {
        const ruleKey = String(ruleCode);
        if (!updated.rules[ruleKey]) {
          // ìƒˆë¡œìš´ ë£°ì´ë©´ ìƒˆë¡œ ìƒì„±
          updated.rules[ruleKey] = {
            count: 0,
            name: `Rule ${ruleCode}`, // ë°±ì—”ë“œì—ì„œ ì‹¤ì œ ì´ë¦„ ë°›ì•„ì˜¬ ë•Œê¹Œì§€ ì„ì‹œ
            color: generateRuleColor(ruleCode)
          };
          console.log(`    Created new rule legend: ${ruleKey}`);
        }
        updated.rules[ruleKey].count++;
        console.log(`    Incremented count for rule ${ruleKey}: ${updated.rules[ruleKey].count}`);
      });
    } else {
      console.log(`  Node ${node.id} has no traits or invalid traits array`);
    }
  });
  
  console.log('Final updated rules:', updated.rules);
  
  return updated;
}
function renderLegend(legend){
  const t = document.getElementById('traitLegend');
  const r = document.getElementById('ruleLegend');
  t.innerHTML = '';
  r.innerHTML = '';
  
  // í´ë¦­ ê°€ëŠ¥í•œ íŠ¸ë ˆì´íŠ¸ ë²”ë¡€ í•­ëª© ìƒì„±
  const mkTrait = (color,name,count,traitCode)=>`<div class="legend-item" data-trait="${traitCode||''}" style="cursor:pointer;padding:4px;border-radius:4px;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background=''"onclick="toggleTraitHighlight('${traitCode||''}','${color}')"><div class="legend-color" style="background:${color}"></div><span>${name} <small style="color:#888;">(${traitCode})</small></span><span style="margin-left:auto;color:#888;font-size:11px">${count}</span></div>`;
  
  // í´ë¦­ ê°€ëŠ¥í•œ ë£° ë²”ë¡€ í•­ëª© ìƒì„±
  const mkRule = (color,name,count,ruleId)=>`<div class="legend-item" data-rule="${ruleId||''}" style="cursor:pointer;padding:4px;border-radius:4px;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background=''"onclick="toggleRuleHighlight('${ruleId||''}','${color}')"><div class="legend-color" style="background:${color}"></div><span>${name} <small style="color:#888;">(${ruleId})</small></span><span style="margin-left:auto;color:#888;font-size:11px">${count}</span></div>`;
  
  // Multi-Trait í•­ëª©ì„ ë§¨ ìœ„ì— ì¶”ê°€ (ì‹¤ì œ ë©€í‹° íŠ¸ë ˆì´íŠ¸ ì—°ê²°ëœ ë…¸ë“œ ìˆ˜ ê³„ì‚°)
  let multiTraitNodes = new Set();
  // CURRENT ê·¸ë˜í”„ì—ì„œ parallelCount > 1ì¸ ì—£ì§€ë“¤ì˜ ë…¸ë“œë“¤ì„ ìˆ˜ì§‘
  if (CURRENT && CURRENT.edges) {
    CURRENT.edges.forEach(edge => {
      const cnt = edge.parallelCount || 1;
      if (cnt > 1) {
        multiTraitNodes.add(edge.source);
        multiTraitNodes.add(edge.target);
      }
    });
  }
  const multiTraitCount = multiTraitNodes.size;
  t.insertAdjacentHTML('beforeend', mkTrait('#000000', 'Multi-Trait', multiTraitCount, 'multi'));
  
  // ê¸°ì¡´ íŠ¸ë ˆì´íŠ¸ë“¤
  for (const k in (legend.traits||{})) {
    const it = legend.traits[k]; 
    t.insertAdjacentHTML('beforeend', mkTrait(it.color, it.name, it.count||0, k));
  }
  
  // Rule ë²”ë¡€ë“¤
  for (const k in (legend.rules||{})) {
    const it = legend.rules[k]; 
    r.insertAdjacentHTML('beforeend', mkRule(it.color, it.name, it.count||0, k));
  }
}

// PolyTrait ìƒ‰ìƒ ìƒì„± í•¨ìˆ˜
function generatePolyTraitColor(polyTraitCode) {
  // PolyTraitë³„ë¡œ ê³ ìœ í•œ ìƒ‰ìƒ ìƒì„± (ë” ë°ê³  ëˆˆì— ë„ëŠ” ìƒ‰ìƒ)
  const h = (polyTraitCode * 73 + 180) % 360;  // 73ì€ ì†Œìˆ˜
  const s = 80 + (polyTraitCode % 2) * 10;     // 80-90% ì±„ë„ (ë” ì„ ëª…í•˜ê²Œ)
  const l = 50 + (polyTraitCode % 3) * 10;     // 50-70% ëª…ë„ (ë” ë°ê²Œ)
  return `hsl(${h}, ${s}%, ${l}%)`;
}

// PolyTrait ë²”ë¡€ ë°ì´í„° ë¡œë“œ
function loadPolyTraitLegend() {
  console.log('=== Loading PolyTrait legend from server ===');
  
  const url = '/api/triplet/graph/polytrait/legend';
  console.log('Fetching URL:', url);
  
  fetch(url)
    .then(response => {
      console.log('PolyTrait legend response status:', response.status);
      console.log('PolyTrait legend response ok:', response.ok);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response.json();
    })
    .then(legend => {
      console.log('=== PolyTrait legend loaded successfully ===');
      console.log('Raw server response:', legend);
      console.log('Legend keys:', Object.keys(legend));
      
      if (!legend || Object.keys(legend).length === 0) {
        console.warn('PolyTrait legend is empty or null');
        return;
      }
      
      polyTraitLegendData = legend;
      
      // ìƒ‰ìƒ ì¶”ê°€ ë° ë°ì´í„° ì •ê·œí™” (ì„œë²„ì—ì„œ ìƒ‰ìƒì„ ì œê³µí•˜ì§€ ì•ŠëŠ” ê²½ìš°)
      for (const [code, info] of Object.entries(legend)) {
        console.log(`Processing PolyTrait ${code}:`, info);
        
        // ì„œë²„ ì‘ë‹µì˜ Nameì„ nameìœ¼ë¡œ ì •ê·œí™”
        if (info.Name && !info.name) {
          info.name = info.Name;
        }
        
        if (!info.color) {
          info.color = generatePolyTraitColor(parseInt(code));
          console.log(`Generated color for ${code}:`, info.color);
        }
        
        console.log(`PolyTrait ${code} processed:`, {name: info.name, color: info.color});
      }
      
      console.log('Final polyTraitLegendData:', polyTraitLegendData);
      renderPolyTraitLegend();
    })
    .catch(err => {
      console.error('=== Failed to load PolyTrait legend ===');
      console.error('Error details:', err);
      console.error('Error message:', err.message);
      
      // ì—ëŸ¬ì‹œ ë¹ˆ ë²”ë¡€ í‘œì‹œ
      polyTraitLegendData = {};
      renderPolyTraitLegend();
    });
}

// PolyTrait ë²”ë¡€ ë Œë”ë§
function renderPolyTraitLegend() {
  console.log('=== Rendering PolyTrait legend ===');
  
  const pt = document.getElementById('polyTraitLegend');
  if (!pt) {
    console.error('PolyTrait legend container not found');
    return;
  }
  
  console.log('PolyTrait legend container found');
  console.log('polyTraitLegendData entries:', Object.keys(polyTraitLegendData).length);
  
  pt.innerHTML = '';
  
  if (Object.keys(polyTraitLegendData).length === 0) {
    console.log('No PolyTrait data to render');
    pt.innerHTML = '<div style="color:#888;font-style:italic;">No PolyTraits available</div>';
    return;
  }
  
  // í´ë¦­ ê°€ëŠ¥í•œ PolyTrait ë²”ë¡€ í•­ëª© ìƒì„±
  const mkPolyTrait = (color, name, polyTraitCode, traitCodes) => `<div class="legend-item" data-polytrait="${polyTraitCode||''}" style="cursor:pointer;padding:4px;border-radius:4px;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background=''" onclick="togglePolyTraitHighlight('${polyTraitCode||''}','${color}')"><div class="legend-color" style="background:${color}"></div><span>${name} <small style="color:#888;">(${polyTraitCode}) [${traitCodes}]</small></span></div>`;
  
  // PolyTrait ë²”ë¡€ë“¤
  let renderedCount = 0;
  for (const [code, info] of Object.entries(polyTraitLegendData)) {
    const color = info.color || generatePolyTraitColor(parseInt(code));
    const name = info.name || `PolyTrait ${code}`;
    const traits = info.Traits || info.traits || [];
    const traitCodes = traits.join(', ');
    
    console.log(`Rendering PolyTrait ${code}: ${name} (${color}) with traits: [${traitCodes}]`);
    pt.insertAdjacentHTML('beforeend', mkPolyTrait(color, name, code, traitCodes));
    renderedCount++;
  }
  
  console.log(`Successfully rendered ${renderedCount} PolyTrait legend items`);
}

// PolyRope ê²€ìƒ‰ ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
function showPolyRopeResult(result) {
  const panel = document.getElementById('polyRopeResultPanel');
  const content = document.getElementById('polyRopeResultContent');
  
  if (!result) {
    panel.style.display = 'none';
    return;
  }
  
  let html = '';
  html += '<div><b>Address 1:</b> ' + (result.address1 ? result.address1.substring(0, 10) + '...' : 'N/A') + '</div>';
  html += '<div><b>Address 2:</b> ' + (result.address2 ? result.address2.substring(0, 10) + '...' : 'N/A') + '</div>';
  html += '<div><b>PolyTrait:</b> ' + (result.polytraitcode || 'N/A') + '</div>';
  html += '<div><b>Connected:</b> <span style="color:' + (result.in_same_rope ? '#28a745' : '#dc3545') + ';font-weight:bold;">' + (result.in_same_rope ? 'âœ… YES' : 'âŒ NO') + '</span></div>';
  
  if (polyTraitLegendData[result.polytraitcode]) {
    html += '<div><b>PolyTrait Name:</b> ' + polyTraitLegendData[result.polytraitcode].name + '</div>';
  }
  
  content.innerHTML = html;
  panel.style.display = 'block';
}

function hidePolyRopeResult() {
  const panel = document.getElementById('polyRopeResultPanel');
  panel.style.display = 'none';
}

// í•˜ì´ë¼ì´íŒ… ìƒíƒœ ê´€ë¦¬
let currentHighlightTrait = null;
let currentHighlightRule = null;

function toggleTraitHighlight(traitCode, color) {
  if (currentHighlightTrait === traitCode) {
    // ì´ë¯¸ ì„ íƒëœ íŠ¸ë ˆì´íŠ¸ë©´ í•˜ì´ë¼ì´íŒ… í•´ì œ
    currentHighlightTrait = null;
    f.contentWindow.postMessage({type: 'highlight-trait', payload: {traitCode: null}}, '*');
  } else {
    // ìƒˆë¡œìš´ íŠ¸ë ˆì´íŠ¸ í•˜ì´ë¼ì´íŒ…
    currentHighlightTrait = traitCode;
    f.contentWindow.postMessage({type: 'highlight-trait', payload: {traitCode, color}}, '*');
  }
}

function toggleRuleHighlight(ruleId, color) {
  // ìš°ì„ ìˆœìœ„ ì œì•½ ì œê±° - íŠ¸ë ˆì´íŠ¸ í•˜ì´ë¼ì´íŒ… ìƒíƒœì™€ ë¬´ê´€í•˜ê²Œ ì‘ë™
  if (currentHighlightRule === ruleId) {
    // ì´ë¯¸ ì„ íƒëœ Ruleì´ë©´ í•˜ì´ë¼ì´íŒ… í•´ì œ
    currentHighlightRule = null;
    f.contentWindow.postMessage({type: 'highlight-rule', payload: {ruleId: null}}, '*');
  } else {
    // ìƒˆë¡œìš´ Rule í•˜ì´ë¼ì´íŒ…
    currentHighlightRule = ruleId;
    f.contentWindow.postMessage({type: 'highlight-rule', payload: {ruleId, color}}, '*');
  }
}

function getCurrentRuleColor(ruleId) {
  if (CURRENT && CURRENT.legend && CURRENT.legend.rules && CURRENT.legend.rules[ruleId]) {
    return CURRENT.legend.rules[ruleId].color;
  }
  return generateRuleColor(ruleId);
}

// Trait í•˜ì´ë¼ì´íŒ…ë§Œ í•´ì œ
function recoverTrait() {
  console.log('Recovering trait highlighting...');
  
  // Trait í•˜ì´ë¼ì´íŒ… ìƒíƒœë§Œ ì´ˆê¸°í™”
  currentHighlightTrait = null;
  
  // í”„ë ˆì„ì— Trait í•´ì œ ì‹ í˜¸ ì „ì†¡
  f.contentWindow.postMessage({type: 'highlight-trait', payload: {traitCode: null}}, '*');
  
  // ì•Œë¦¼ í‘œì‹œ
  showNotification('Trait í•˜ì´ë¼ì´íŒ…ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
}

// Rule í•˜ì´ë¼ì´íŒ…ë§Œ í•´ì œ
function recoverRule() {
  console.log('Recovering rule highlighting...');
  
  // Rule í•˜ì´ë¼ì´íŒ… ìƒíƒœë§Œ ì´ˆê¸°í™”
  currentHighlightRule = null;
  
  // í”„ë ˆì„ì— Rule í•´ì œ ì‹ í˜¸ ì „ì†¡
  f.contentWindow.postMessage({type: 'highlight-rule', payload: {ruleId: null}}, '*');
  
  // ì•Œë¦¼ í‘œì‹œ
  showNotification('Rule í•˜ì´ë¼ì´íŒ…ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
}

function togglePolyTraitHighlight(polyTraitCode, color) {
  console.log('=== togglePolyTraitHighlight called ===');
  console.log('Input polyTraitCode:', polyTraitCode);
  console.log('Input color:', color);
  console.log('Current currentHighlightPolyTrait:', currentHighlightPolyTrait);
  
  if (currentHighlightPolyTrait === polyTraitCode) {
    // ì´ë¯¸ ì„ íƒëœ PolyTraitë©´ í•˜ì´ë¼ì´íŒ… í•´ì œ
    console.log('Disabling PolyTrait highlight');
    currentHighlightPolyTrait = null;
    f.contentWindow.postMessage({type: 'highlight-polytrait', payload: {polyTraitCode: null}}, '*');
  } else {
    // ìƒˆë¡œìš´ PolyTrait í•˜ì´ë¼ì´íŒ…
    console.log('Enabling PolyTrait highlight');
    currentHighlightPolyTrait = polyTraitCode;
    
    // PolyTrait ë°ì´í„°ë„ í•¨ê»˜ ì „ë‹¬ (ì „ì²´ legend ë°ì´í„°ë¥¼ ì „ë‹¬)
    console.log('Sending complete PolyTrait legend data to frame');
    console.log('polyTraitLegendData keys:', Object.keys(polyTraitLegendData));
    console.log('Target polyTraitCode:', polyTraitCode);
    
    f.contentWindow.postMessage({
      type: 'highlight-polytrait', 
      payload: {
        polyTraitCode, 
        color,
        polyTraitData: polyTraitLegendData
      }
    }, '*');
  }
}

// PolyTrait í•˜ì´ë¼ì´íŒ…ë§Œ í•´ì œ
function recoverPolyTrait() {
  console.log('Recovering PolyTrait highlighting...');
  
  // PolyTrait í•˜ì´ë¼ì´íŒ… ìƒíƒœë§Œ ì´ˆê¸°í™”
  currentHighlightPolyTrait = null;
  
  // í”„ë ˆì„ì— PolyTrait í•´ì œ ì‹ í˜¸ ì „ì†¡
  f.contentWindow.postMessage({type: 'highlight-polytrait', payload: {polyTraitCode: null}}, '*');
  
  // ì•Œë¦¼ í‘œì‹œ
  showNotification('PolyTrait í•˜ì´ë¼ì´íŒ…ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
}

// ë©”ì‹œì§€(ìì‹ â†’ ë¶€ëª¨)
window.addEventListener('message', (ev)=>{
  const msg = ev.data||{};
  if (msg.type==='child-mounted'){
    // ì´ˆê¸° ë¡œë“œ
    fetch('/api/triplet/graph/default').then(r=>r.json()).then(g=>{
      CURRENT = g; syncStats(CURRENT); renderLegend(CURRENT.legend||{traits:{}, rules:{}});
      resetInfoPanel(); // Info íŒ¨ë„ ì´ˆê¸°í™”
      hideRopeInfo(); // ë¡œí”„ ì •ë³´ ìˆ¨ê¹€
      hidePolyRopeResult(); // PolyRope ê²€ìƒ‰ ê²°ê³¼ ìˆ¨ê¹€
      loadPolyTraitLegend(); // PolyTrait ë²”ë¡€ ë¡œë“œ
      f.contentWindow.postMessage({type:'load-graph', payload: CURRENT}, '*');
    });
  } else if (msg.type==='child-ready'){
    // ok ì—¬ë¶€ë§Œ í™•ì¸ ê°€ëŠ¥
  } else if (msg.type==='node-hover'){
    // Payloadê°€ ì—†ìœ¼ë©´ ì •ë³´ë¥¼ ìœ ì§€ (ë§ˆìš°ìŠ¤ê°€ leaveí•´ë„ ê³„ì† í‘œì‹œ)
    if (!msg.payload) { return; }
    
    console.log('Received node-hover payload:', msg.payload);
    console.log('ropes array:', msg.payload.ropes);
    console.log('ropeId:', msg.payload.ropeId);
    console.log('ropeCount:', msg.payload.ropeCount);
    
    nodeBox.classList.remove('muted');
    const p = msg.payload;
    
    // ê¸°ë³¸ ì •ë³´
    let html = 'Address: <span class="mono">' + (p.id || '') + '</span>';
    
    // ë¡œí”„ ì •ë³´ - ëª¨ë“  ë¡œí”„ IDë¥¼ í‘œì‹œ
    console.log('Checking if ropeCount > 0:', p.ropeCount, '>', 0, '=', p.ropeCount > 0);
    if (p.ropeCount > 0) {
      html += '<br/>Ropes: <b>' + p.ropeCount + '</b>';
      
      console.log('Checking ropes condition:');
      console.log('p.ropes:', p.ropes);
      console.log('p.ropes.length:', p.ropes ? p.ropes.length : 'undefined');
      console.log('p.ropeId:', p.ropeId);
      
      // ëª¨ë“  ë¡œí”„ ID í‘œì‹œ
      if (p.ropes && p.ropes.length > 0) {
        console.log('Using ropes array');
        // ropes ë°°ì—´ì´ ìˆëŠ” ê²½ìš° ëª¨ë“  ID í‘œì‹œ
        html += '<br/>IDs: ';
        const ropeIds = p.ropes.map(rope => '#' + rope.id).join(', ');
        html += '<span class="mono">' + ropeIds + '</span>';
        console.log('Generated ropeIds:', ropeIds);
      } else if (p.ropeId && p.ropeId !== 0) {
        console.log('Using fallback ropeId');
        // ê¸°ì¡´ ë°©ì‹ í˜¸í™˜ì„± (ropes ë°°ì—´ì´ ì—†ëŠ” ê²½ìš°) - ìµœì†Œí•œ primary IDëŠ” í‘œì‹œ
        html += '<br/>IDs: <span class="mono">#' + p.ropeId + '</span>';
      } else {
        console.log('No rope IDs to display');
      }
    }
    
    // íŠ¸ë ˆì´íŠ¸ ì •ë³´
    if (p.traitCount > 0) {
      html += '<br/>Traits: <b>' + p.traitCount + '</b>';
      if (p.traits && p.traits.length > 0) {
        html += '<br/>Types: ';
        const traitNames = p.traits.slice(0, 3).map(t => t.traitName || 'code ' + t.traitCode).join(', ');
        html += '<span class="muted">' + traitNames;
        if (p.traits.length > 3) {
          html += ' +' + (p.traits.length - 3) + ' more';
        }
        html += '</span>';
      }
    }
    
    // ì •ë³´ê°€ ì—†ì„ ê²½ìš°
    if (p.ropeCount === 0 && p.traitCount === 0) {
      html += '<br/><span class="muted">No connections</span>';
    }
    
    nodeBox.innerHTML = html;
  } else if (msg.type==='edge-hover'){
    // Payloadê°€ ì—†ìœ¼ë©´ ì •ë³´ë¥¼ ìœ ì§€ (ë§ˆìš°ìŠ¤ê°€ leaveí•´ë„ ê³„ì† í‘œì‹œ)
    if (!msg.payload) { return; }
    edgeBox.classList.remove('muted');
    const p = msg.payload;
    
    if (p.isMultiTrait && p.traits) {
      // ë©€í‹° íŠ¸ë ˆì´íŠ¸ ì •ë³´ í‘œì‹œ
      let html = '<b>Multi-Trait Connection (' + p.totalTraits + ' traits):</b><br/>';
      p.traits.forEach((trait, index) => {
        html += (index > 0 ? '<br/>' : '') + 
                'â€¢ <b>' + (trait.traitName || ('code ' + trait.traitCode)) + '</b> ' +
                '<span class="mono">#' + (trait.traitId || 0) + '</span>';
      });
      edgeBox.innerHTML = html;
    } else {
      // ë‹¨ì¼ íŠ¸ë ˆì´íŠ¸ ì •ë³´ í‘œì‹œ
      edgeBox.innerHTML = 'Trait: <b>'+(p.traitName||('code '+p.traitCode))+'</b> <span class="mono">#'+(p.traitId||0)+'</span>';
    }
  } else if (msg.type==='node-click'){
    const id = msg.payload && msg.payload.id;
    if (!id) return;
    
    // ë…¸ë“œ í™•ì¥ í™•ì¸ ëŒ€í™”ìƒì
    const shortId = id.length > 10 ? id.substr(0, 6) + '..' + id.substr(-4) : id;
    const confirmExpand = confirm(`ë…¸ë“œ "${shortId}"ë¥¼ 1-hop í™•ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì—°ê²°ëœ ë…¸ë“œë“¤ì´ ê·¸ë˜í”„ì— ì¶”ê°€ë©ë‹ˆë‹¤.`);
    
    if (confirmExpand) {
      console.log(`=== NODE EXPANSION (PURE DB MODE): ${shortId} ===`);
      
      fetch('/api/triplet/graph/expand?v='+encodeURIComponent(id))
        .then(r=>r.json()).then(expandResult=>{
          console.log('Pure DB expansion result:', {
            nodes: expandResult.nodes?.length || 0,
            edges: expandResult.edges?.length || 0,
            error: expandResult.error
          });
          
          if (expandResult.error) {
            console.error(`Expansion failed: ${expandResult.error}`);
            alert('ë…¸ë“œ í™•ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + expandResult.error);
            return;
          }
          
          // ê¸°ì¡´ ê·¸ë˜í”„ì— í™•ì¥ ê²°ê³¼ ì¶”ê°€ (apply-graph ì‚¬ìš©)
          console.log('Adding expansion results to existing graph');
          
          // ì—…ë°ì´íŠ¸ ì „ì— ê¸°ì¡´ ë…¸ë“œ/ì—£ì§€ ID ì €ì¥ (ë¹„êµìš©)
          const existingNodeIds = new Set((CURRENT.nodes || []).map(n => n.id));
          const existingEdgeIds = new Set((CURRENT.edges || []).map(e => e.id));
          
          // ì‹¤ì œë¡œ ìƒˆë¡œ ì¶”ê°€ë  ë…¸ë“œì™€ ì—£ì§€ ë¯¸ë¦¬ ê³„ì‚°
          const trulyNewNodes = (expandResult.nodes || []).filter(n => !existingNodeIds.has(n.id));
          const trulyNewEdges = (expandResult.edges || []).filter(e => !existingEdgeIds.has(e.id));
          
          console.log('Truly new elements:', {
            newNodes: trulyNewNodes.length,
            newEdges: trulyNewEdges.length,
            existingNodes: existingNodeIds.size,
            existingEdges: existingEdgeIds.size
          });
          
          // CURRENTì— ìƒˆë¡œìš´ ë…¸ë“œì™€ ì—£ì§€ ì¶”ê°€ (ë¸Œë¼ìš°ì € ìƒíƒœ ë™ê¸°í™”)
          const nodeMap = new Map();
          const edgeMap = new Map();
          
          // ê¸°ì¡´ ë…¸ë“œ/ì—£ì§€ ì¶”ê°€
          (CURRENT.nodes || []).forEach(n => nodeMap.set(n.id, n));
          (CURRENT.edges || []).forEach(e => edgeMap.set(e.id, e));
          
          // í™•ì¥ ê²°ê³¼ ë…¸ë“œ/ì—£ì§€ ì¶”ê°€
          (expandResult.nodes || []).forEach(n => nodeMap.set(n.id, n));
          (expandResult.edges || []).forEach(e => edgeMap.set(e.id, e));
          
          // CURRENT ì—…ë°ì´íŠ¸
          CURRENT.nodes = [...nodeMap.values()];
          CURRENT.edges = [...edgeMap.values()];
          CURRENT.meta = {
            ...CURRENT.meta,
            nodeCount: CURRENT.nodes.length,
            edgeCount: CURRENT.edges.length,
            generatedAt: Math.floor(Date.now()/1000)
          };
          
          // ë²”ë¡€ ë³‘í•© ë° ì¬ê³„ì‚° (ê¸°ì¡´ ë²”ë¡€ ìƒ‰ìƒì„ ìœ ì§€í•˜ë©´ì„œ ìƒˆë¡œìš´ ë°ì´í„° ì¶”ê°€ í›„ ì¹´ìš´íŠ¸ ì¬ê³„ì‚°)
          if (expandResult.legend) {
            // 1ë‹¨ê³„: ë²”ë¡€ ë³‘í•© (ìƒ‰ìƒ ì¼ê´€ì„± ìœ ì§€)
            CURRENT.legend = mergeLegends(CURRENT.legend || {traits:{}, rules:{}}, expandResult.legend);
            // 2ë‹¨ê³„: í˜„ì¬ ê·¸ë˜í”„ ìƒíƒœ ê¸°ë°˜ìœ¼ë¡œ ì¹´ìš´íŠ¸ ì¬ê³„ì‚°
            CURRENT.legend = recalculateLegendCounts(CURRENT.legend, CURRENT.nodes, CURRENT.edges);
          }
          
          console.log('Graph expansion completed:', { 
            before: { nodes: existingNodeIds.size, edges: existingEdgeIds.size },
            received: { nodes: expandResult.nodes?.length || 0, edges: expandResult.edges?.length || 0 },
            added: { nodes: trulyNewNodes.length, edges: trulyNewEdges.length },
            after: { nodes: CURRENT.nodes.length, edges: CURRENT.edges.length }
          });
          
          const addedNodes = trulyNewNodes.length;
          const addedEdges = trulyNewEdges.length;
          
          // í™•ì¥ ê²°ê³¼ ì•Œë¦¼ ë©”ì‹œì§€ ìƒì„±
          if (addedNodes > 0 || addedEdges > 0) {
            let notificationMsg = `âœ… í™•ì¥ ì™„ë£Œ: ${addedNodes}ê°œ ë…¸ë“œ, ${addedEdges}ê°œ ì—°ê²° ì¶”ê°€`;
            
            // ì‹¤ì œë¡œ ì¶”ê°€ëœ ë…¸ë“œ ì£¼ì†Œ í‘œì‹œ (ìµœëŒ€ 3ê°œ)
            if (trulyNewNodes.length > 0) {
              const newAddresses = trulyNewNodes
                .filter(n => n.id !== id) // í´ë¦­í•œ ë…¸ë“œ ì œì™¸
                .slice(0, 3)
                .map(n => {
                  const addr = n.id;
                  return addr.length > 10 ? addr.substr(0, 6) + '..' + addr.substr(-4) : addr;
                });
              
              if (newAddresses.length > 0) {
                notificationMsg += '<br/>ìƒˆ ë…¸ë“œ: ' + newAddresses.join(', ');
                const remainingCount = trulyNewNodes.filter(n => n.id !== id).length - 3;
                if (remainingCount > 0) {
                  notificationMsg += ` ì™¸ ${remainingCount}ê°œ`;
                }
              }
            }
            
            showNotification(notificationMsg, 2500);
          } else {
            showNotification('â„¹ï¸ ì´ë¯¸ ëª¨ë“  ì—°ê²°ì´ í‘œì‹œë˜ê³  ìˆìŠµë‹ˆë‹¤', 2000);
          }
          
          syncStats(CURRENT); 
          renderLegend(CURRENT.legend||{traits:{}, rules:{}});
          
          // í”„ë ˆì„ì— ì¦ë¶„ ë°ì´í„°ì™€ í•¨ê»˜ ì—…ë°ì´íŠ¸ëœ ë²”ë¡€ ì „ì†¡
          const incrementalUpdate = {
            ...expandResult,
            legend: CURRENT.legend  // ë³‘í•©ëœ ë²”ë¡€ ì‚¬ìš©
          };
          f.contentWindow.postMessage({type:'apply-graph', payload: incrementalUpdate}, '*');
          console.log(`Pure DB expansion completed: ${shortId} (${CURRENT.nodes?.length || 0} nodes, ${CURRENT.edges?.length || 0} edges)`);
        })
        .catch(err => {
          console.error(`Failed to expand node ${shortId}:`, err);
          alert('ë…¸ë“œ í™•ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        });
    }
  }
});

// ê²€ìƒ‰ ë²„íŠ¼ â†’ ì„œë²„ í˜¸ì¶œ
document.getElementById('defBtn').onclick = ()=>{
  console.log('Default button clicked');
  fetch('/api/triplet/graph/default').then(r=>r.json()).then(g=>{
    CURRENT = g; syncStats(CURRENT); renderLegend(CURRENT.legend||{traits:{}, rules:{}});
    resetInfoPanel(); // Info íŒ¨ë„ ì´ˆê¸°í™”
    hideRopeInfo(); // ë¡œí”„ ì •ë³´ ìˆ¨ê¹€
    hidePolyRopeResult(); // PolyRope ê²€ìƒ‰ ê²°ê³¼ ìˆ¨ê¹€
    loadPolyTraitLegend(); // PolyTrait ë²”ë¡€ ë‹¤ì‹œ ë¡œë“œ
    f.contentWindow.postMessage({type:'load-graph', payload: CURRENT}, '*');
  });
};

// ë²„íŠ¼ ì´ë²¤íŠ¸ ë“±ë¡ í™•ì¸
console.log('=== BUTTON EVENT REGISTRATION ===');
console.log('addrBtn element:', document.getElementById('addrBtn'));
console.log('ropeBtn element:', document.getElementById('ropeBtn'));
console.log('defBtn element:', document.getElementById('defBtn'));
console.log('=== EVENT HANDLERS REGISTERED ===');
// ì£¼ì†Œ ê²€ìƒ‰: í•´ë‹¹ ì£¼ì†Œë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ê·¸ë˜í”„ ì´ˆê¸°í™” + 1-hop í™•ì¥
document.getElementById('addrBtn').onclick = ()=>{
  console.log('=== ADDRESS SEARCH (RESET MODE) ===');
  const addr = (document.getElementById('addr').value||'').trim();
  console.log('Searching address:', addr);
  
  if (!addr) {
    return alert('ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: 0x1234...)');
  }
  
  const url = '/api/triplet/graph/expand?v='+encodeURIComponent(addr);
  console.log('Request URL:', url);
  
  fetch(url)
    .then(r => r.json())
    .then(searchResult => {
      console.log('Search result:', {
        nodes: searchResult.nodes?.length || 0,
        edges: searchResult.edges?.length || 0,
        error: searchResult.error
      });
      
      if (searchResult.error) {
        alert('ì£¼ì†Œ ê²€ìƒ‰ ì‹¤íŒ¨: ' + searchResult.error);
        return;
      }
      
      // ê·¸ë˜í”„ ì™„ì „ ì´ˆê¸°í™” (DB ê²°ê³¼ë¡œ ì™„ì „ ëŒ€ì²´, ë³‘í•© ì—†ìŒ)
      console.log('Replacing current graph with pure DB search results (no merge)');
      CURRENT = searchResult;
      
      // ê·¸ë˜í”„ ë©”íƒ€ ì •ë³´ ì„¤ì •
      CURRENT.meta = {
        ...CURRENT.meta,
        generatedAt: Math.floor(Date.now()/1000),
        graphType: 'search-address',
        startNode: addr
      };
      
      syncStats(CURRENT); 
      renderLegend(CURRENT.legend||{traits:{}, rules:{}});
      resetInfoPanel(); // Info íŒ¨ë„ ì´ˆê¸°í™”
      hideRopeInfo(); // ë¡œí”„ ì •ë³´ ìˆ¨ê¹€
      
      // iframe ìƒˆë¡œê³ ì¹¨ ì—†ì´ ê·¸ë˜í”„ë§Œ ì™„ì „ ë¦¬ì…‹ í›„ ìƒˆ ë°ì´í„° ë¡œë“œ
      console.log('=== RESETTING GRAPH WITHOUT IFRAME RELOAD ===');
      console.log('New search graph data:', CURRENT);
      
      // load-graph ë©”ì‹œì§€ë¡œ ì™„ì „í•œ ê·¸ë˜í”„ êµì²´ ìˆ˜í–‰
      f.contentWindow.postMessage({type:'load-graph', payload: CURRENT}, '*');
      
      console.log(`Address search completed: ${addr} (${CURRENT.nodes?.length || 0} nodes, ${CURRENT.edges?.length || 0} edges)`);
    })
    .catch(err => {
      console.error('Address search error:', err);
      alert('ì£¼ì†Œ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + err.message);
    });
};

// Rope ê²€ìƒ‰: í•´ë‹¹ Ropeë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ê·¸ë˜í”„ ì´ˆê¸°í™” (ì™„ì „íˆ DB ê¸°ë°˜, ë³‘í•© ì—†ìŒ)
document.getElementById('ropeBtn').onclick = ()=>{
  const ropeId = (document.getElementById('rope').value||'').trim();
  if (!ropeId) return alert('Rope IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: 1, 2, 3)');
  
  console.log(`=== ROPE SEARCH (PURE DB MODE): ${ropeId} ===`);
  
  // ë‹¨ì¼ DB í˜¸ì¶œ: FetchGraphByRopeIDëŠ” ì´ë¯¸ rope ë©¤ë²„ë“¤ + 1-hop í™•ì¥ì„ DBì—ì„œ ê³„ì‚°í•¨ (depth=2)
  const url = '/api/triplet/graph/rope/'+encodeURIComponent(ropeId);
  console.log('Request URL:', url);
  
  fetch(url)
    .then(r => r.json())
    .then(searchResult => {
      console.log('Pure DB rope search result:', {
        nodes: searchResult.nodes?.length || 0,
        edges: searchResult.edges?.length || 0,
        error: searchResult.error
      });
      
      if (searchResult.error) {
        alert('Rope ê²€ìƒ‰ ì‹¤íŒ¨: ' + searchResult.error);
        return;
      }
      
      // ê·¸ë˜í”„ ì™„ì „ ì´ˆê¸°í™” (ìˆœìˆ˜ DB ê²°ê³¼, ë¸Œë¼ìš°ì € ìƒíƒœ ë³‘í•© ì—†ìŒ)
      console.log('Replacing current graph with pure DB rope results (no browser merging)');
      CURRENT = searchResult;
      
      // ê·¸ë˜í”„ ë©”íƒ€ ì •ë³´ ì„¤ì •
      CURRENT.meta = {
        ...CURRENT.meta,
        generatedAt: Math.floor(Date.now()/1000),
        graphType: 'search-rope',
        startNode: `Rope ${ropeId}`
      };
      
      syncStats(CURRENT);
      renderLegend(CURRENT.legend||{traits:{}, rules:{}});
      resetInfoPanel(); // Info íŒ¨ë„ ì´ˆê¸°í™”
      
      // iframe ìƒˆë¡œê³ ì¹¨ ì—†ì´ ê·¸ë˜í”„ë§Œ ì™„ì „ ë¦¬ì…‹ í›„ ìƒˆ ë°ì´í„° ë¡œë“œ
      console.log('=== RESETTING ROPE GRAPH WITHOUT IFRAME RELOAD ===');
      console.log('Pure DB rope graph data:', CURRENT);
      
      // load-graph ë©”ì‹œì§€ë¡œ ì™„ì „í•œ ê·¸ë˜í”„ êµì²´ ìˆ˜í–‰
      f.contentWindow.postMessage({type:'load-graph', payload: CURRENT}, '*');
      
      // ë¡œí”„ ì •ë³´ ë¡œë“œ
      loadRopeInfo(ropeId);
      
      console.log(`Pure DB rope search completed: ${ropeId} (${CURRENT.nodes?.length || 0} nodes, ${CURRENT.edges?.length || 0} edges)`);
    })
    .catch(err => {
      console.error('Rope search error:', err);
      alert('Rope ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + err.message);
    });
};

// PolyRope ê²€ìƒ‰
document.getElementById('polyRopeBtn').onclick = ()=>{
  const addr1 = (document.getElementById('polyAddr1').value||'').trim();
  const addr2 = (document.getElementById('polyAddr2').value||'').trim();
  const polyTraitCode = (document.getElementById('polyTraitCode').value||'').trim();
  
  if (!addr1 || !addr2 || !polyTraitCode) {
    return alert('ëª¨ë“  í•„ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (Address 1, Address 2, PolyTrait Code)');
  }
  
  console.log(`=== POLYROPE SEARCH ===`, {addr1, addr2, polyTraitCode});
  
  const url = '/api/triplet/graph/polyrope/search?address1=' + encodeURIComponent(addr1) + '&address2=' + encodeURIComponent(addr2) + '&polytraitcode=' + encodeURIComponent(polyTraitCode);
  console.log('Request URL:', url);
  
  fetch(url)
    .then(r => r.json())
    .then(result => {
      console.log('PolyRope search result:', result);
      
      if (result.error) {
        alert('PolyRope ê²€ìƒ‰ ì‹¤íŒ¨: ' + result.error);
        hidePolyRopeResult();
        return;
      }
      
      // ê²€ìƒ‰ ê²°ê³¼ í‘œì‹œ
      showPolyRopeResult(result);
      
      // ì„±ê³µ ì•Œë¦¼
      const connected = result.in_same_rope ? 'ì—°ê²°ë¨' : 'ì—°ê²° ì•ˆë¨';
      showNotification(`ğŸ”— PolyRope ê²€ìƒ‰ ì™„ë£Œ: ${connected}`, 2000);
    })
    .catch(err => {
      console.error('PolyRope search error:', err);
      alert('PolyRope ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + err.message);
      hidePolyRopeResult();
    });
};
</script>
</body>
</html>
