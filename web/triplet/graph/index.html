<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>RopeDB Visualizer</title>
<style>
  *{box-sizing:border-box}
  html,body{margin:0;height:100vh;scrollbar-gutter:stable both-edges}
  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    display:grid;grid-template-columns:60% 40%;grid-template-rows:60% 40%;
    gap:10px;background:#f5f5f5;padding:10px
  }
  #graph,#search,#legend,#info{background:#fff;border-radius:10px;box-shadow:0 2px 10px rgba(0,0,0,.08);overflow:hidden}
  #graph{grid-column:1;grid-row:1;overflow:hidden;overscroll-behavior:contain}
  #search{grid-column:2;grid-row:1;padding:16px}
  #info{grid-column:1;grid-row:2;padding:16px}
  #legend{grid-column:2;grid-row:2;padding:16px}
  #f{width:100%;height:100%;border:0;overflow:hidden;display:block}
  .sec h3{margin:0 0 10px 0;font-size:14px;color:#333}
  .row{margin-bottom:12px}
  input[type=text]{width:100%;padding:10px;border:1px solid #ddd;border-radius:8px;font-size:13px}
  button{margin-top:6px;width:100%;padding:10px;border:0;border-radius:8px;cursor:pointer;background:#2f6fed;color:#fff;font-weight:600}
  button.green{background:#28a745}
  .legend-item{display:flex;align-items:center;margin-bottom:6px}
  .legend-color{width:16px;height:16px;border-radius:3px;margin-right:8px}
  .kv{font-size:12px;color:#555}.kv b{color:#222}.muted{color:#888;font-size:12px}.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  #info .kv{font-size:15px;font-weight:600;color:#333}
  #info .kv b{color:#111;font-weight:700}
  #info .muted{color:#666;font-size:13px;font-weight:500}
  #info .mono{font-weight:600}
  #info .sec h3{font-size:16px;font-weight:700;color:#222}
  
  /* 알림 메시지 스타일 */
  .notification {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(47, 111, 237, 0.95);
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    font-size: 14px;
    font-weight: 600;
    z-index: 1000;
    animation: slideDown 0.3s ease-out;
    max-width: 500px;
  }
  
  @keyframes slideDown {
    from {
      transform: translateX(-50%) translateY(-100%);
      opacity: 0;
    }
    to {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  }
  
  @keyframes slideUp {
    from {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
    to {
      transform: translateX(-50%) translateY(-100%);
      opacity: 0;
    }
  }
  
  .notification.hiding {
    animation: slideUp 0.3s ease-out;
  }
</style>
</head>
<body>
  <section id="graph"><iframe id="f" src="/ui/triplet/graph/frame" scrolling="no"></iframe></section>

  <section id="search" style="max-height: 90vh; overflow-y: auto; padding-right: 8px;">
    <div class="sec">
      <h3>🔍 Address Search</h3>
      <div class="row"><input id="addr" type="text" placeholder="0x1234..."/></div>
      <button id="addrBtn">Search Address + 1-hop</button>
    </div>
    <div class="sec" style="margin-top:14px">
      <h3>🧵 Rope Search</h3>
      <div class="row"><input id="rope" type="text" placeholder="Rope ID (e.g. 1, 2, 3)"/></div>
      <button id="ropeBtn">Search Rope Members + 1-hop</button>
      
      <!-- 로프 정보 표시 영역 -->
      <div id="ropeInfoPanel" style="margin-top:10px; display:none; padding:8px; background:#f8f9fa; border-radius:6px; border:1px solid #e9ecef;">
        <h4 style="margin:0 0 8px 0; font-size:12px; color:#495057;">📋 Rope Information</h4>
        <div id="ropeInfoContent" class="kv" style="font-size:11px; line-height:1.3;">
          <!-- 로프 정보가 여기에 표시됩니다 -->
        </div>
      </div>
    </div>
    <div class="sec" style="margin-top:14px">
      <h3>🔗 PolyRope Search</h3>
      <div class="row"><input id="polyAddr1" type="text" placeholder="Address 1: 0x1234..."/></div>
      <div class="row"><input id="polyAddr2" type="text" placeholder="Address 2: 0x5678..."/></div>
      <div class="row"><input id="polyTraitCode" type="text" placeholder="PolyTrait Code (e.g. 100)"/></div>
      <button id="polyRopeBtn">Check PolyRope Connection</button>
      
      <!-- PolyRope 검색 결과 표시 영역 -->
      <div id="polyRopeResultPanel" style="margin-top:10px; display:none; padding:8px; background:#f0f8ff; border-radius:6px; border:1px solid #b3d9ff;">
        <h4 style="margin:0 0 8px 0; font-size:12px; color:#1565c0;">🔍 PolyRope Search Result</h4>
        <div id="polyRopeResultContent" class="kv" style="font-size:11px; line-height:1.3;">
          <!-- PolyRope 검색 결과가 여기에 표시됩니다 -->
        </div>
      </div>
    </div>
    <button id="defBtn" class="green" style="margin-top:14px">🏠 Default View</button>
  </section>

  <section id="legend"  style="overflow-y: auto;">
    <div class="sec">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
        <h3 style="margin: 0;">🎨 Trait Colors</h3>
        <button onclick="recoverTrait()" style="background: #ff9800; color: white; border: none; padding: 3px 6px; border-radius: 3px; font-size: 10px; cursor: pointer;" onmouseover="this.style.background='#f57c00'" onmouseout="this.style.background='#ff9800'">Trait 해제</button>
      </div>
      <div id="traitLegend"></div>
    </div>
        <div class="sec" style="margin-top:10px">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
        <h3 style="margin: 0;">🔗 PolyTrait Colors</h3>
        <button onclick="recoverPolyTrait()" style="background: #9c27b0; color: white; border: none; padding: 3px 6px; border-radius: 3px; font-size: 10px; cursor: pointer;" onmouseover="this.style.background='#7b1fa2'" onmouseout="this.style.background='#9c27b0'">PolyTrait 해제</button>
      </div>
      <div id="polyTraitLegend"></div>
    </div>
    <div class="sec" style="margin-top:10px">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
        <h3 style="margin: 0;">📋 Rule Colors</h3>
        <button onclick="recoverRule()" style="background: #2196f3; color: white; border: none; padding: 3px 6px; border-radius: 3px; font-size: 10px; cursor: pointer;" onmouseover="this.style.background='#1976d2'" onmouseout="this.style.background='#2196f3'">Rule 해제</button>
      </div>
      <div id="ruleLegend"></div>
    </div>
  </section>

  <section id="info" style="overflow-y:auto;">
    <div class="sec">
      <h3>ℹ️ Info</h3>
      <div id="stat" class="kv">
        Nodes: <b id="sn">0</b> | Edges: <b id="se">0</b><br/>
        Type: <b id="st">-</b><br/>
        Start: <span id="ss" class="mono muted">-</span>
      </div>
    </div>
    <div class="sec" style="margin-top:10px">
      <h3>Node</h3>
      <div id="nodeBox" class="kv muted">Hover a node…</div>
    </div>
    <div class="sec" style="margin-top:10px">
      <h3>Edge</h3>
      <div id="edgeBox" class="kv muted">Hover an edge…</div>
    </div>
  </section>

<script>
const f = document.getElementById('f');
const sn=document.getElementById('sn'), se=document.getElementById('se'), st=document.getElementById('st'), ss=document.getElementById('ss');
const nodeBox=document.getElementById('nodeBox'), edgeBox=document.getElementById('edgeBox');
let CURRENT = { meta:{}, nodes:[], edges:[], legend:{traits:{}, rules:{}, polyTraits:{}} };

// PolyTrait 관련 상태 및 데이터
let currentHighlightPolyTrait = null;
let polyTraitLegendData = {};

// Info 패널 초기화 함수
function resetInfoPanel() {
  nodeBox.textContent = 'Hover a node…';
  nodeBox.classList.add('muted');
  edgeBox.textContent = 'Hover an edge…';
  edgeBox.classList.add('muted');
}

// 로프 정보 패널 관련 함수들
function showRopeInfo(ropeInfo) {
  const panel = document.getElementById('ropeInfoPanel');
  const content = document.getElementById('ropeInfoContent');
  
  if (!ropeInfo) {
    panel.style.display = 'none';
    return;
  }
  
  // 시간 포맷팅 함수
  const formatTime = (timestamp) => {
    const date = new Date(timestamp * 1000);
    return date.toLocaleString();
  };
  
  // 멤버 주소들을 짧게 표시
  const formatMembers = (members) => {
    if (!members || members.length === 0) return 'None';
    const shortMembers = members.map(addr => {
      if (addr.length > 13) {
        return addr.substring(0, 6) + '..' + addr.substring(addr.length - 4);
      }
      return addr;
    });
    return shortMembers.join(', ');
  };
  
  let html = '';
  html += '<div><b>ID:</b> ' + (ropeInfo.id || 'N/A') + '</div>';
  html += '<div><b>Trait:</b> ' + (ropeInfo.trait || 'N/A') + ' (' + (ropeInfo.traitName || 'Unknown') + ')</div>';
  html += '<div><b>Size:</b> ' + (ropeInfo.size || 'N/A') + '</div>';
  html += '<div><b>Volume:</b> ' + (ropeInfo.volume || 'N/A') + '</div>';
  html += '<div><b>Last Seen:</b> ' + (ropeInfo.lastSeen ? formatTime(ropeInfo.lastSeen) : 'N/A') + '</div>';
  html += '<div><b>Members:</b><br/><span style="font-family:monospace; font-size:10px;">' + formatMembers(ropeInfo.members) + '</span></div>';
  
  content.innerHTML = html;
  panel.style.display = 'block';
}

function hideRopeInfo() {
  const panel = document.getElementById('ropeInfoPanel');
  panel.style.display = 'none';
}

function loadRopeInfo(ropeId) {
  console.log('Loading rope info for rope:', ropeId);
  
  const url = '/api/triplet/graph/rope-info/' + encodeURIComponent(ropeId);
  
  fetch(url)
    .then(r => r.json())
    .then(ropeInfo => {
      console.log('Rope info loaded:', ropeInfo);
      showRopeInfo(ropeInfo);
    })
    .catch(err => {
      console.error('Failed to load rope info:', err);
      hideRopeInfo();
    });
}

// 알림 메시지 표시 함수
function showNotification(message, duration = 2000) {
  // 기존 알림 제거
  const existing = document.querySelector('.notification');
  if (existing) {
    existing.remove();
  }
  
  // 새 알림 생성
  const notification = document.createElement('div');
  notification.className = 'notification';
  notification.innerHTML = message;
  document.body.appendChild(notification);
  
  // 지정된 시간 후 제거
  setTimeout(() => {
    notification.classList.add('hiding');
    setTimeout(() => {
      notification.remove();
    }, 300);
  }, duration);
}

function syncStats(g){
  sn.textContent = String(g.meta?.nodeCount || (g.nodes?g.nodes.length:0) || 0);
  se.textContent = String(g.meta?.edgeCount || (g.edges?g.edges.length:0) || 0);
  st.textContent = g.meta?.graphType || '-';
  ss.textContent = g.meta?.startNode || '-';
}
// Rule 색상 생성 함수
function generateRuleColor(ruleId) {
  // Rule별로 고유한 색상 생성 (트레이트와 다른 색상 범위 사용)
  const h = (ruleId * 137 + 30) % 360;  // 137은 황금비에 가까운 소수
  const s = 55 + (ruleId % 3) * 10;     // 55-75% 채도
  const l = 45 + (ruleId % 4) * 5;      // 45-60% 명도
  return `hsl(${h}, ${s}%, ${l}%)`;
}

// 범례 병합 함수: 기존 범례 색상을 유지하면서 새로운 데이터 추가
function mergeLegends(existingLegend, newLegend) {
  const merged = {
    traits: { ...existingLegend.traits },
    rules: { ...existingLegend.rules }
  };
  
  // 새로운 트레이트들 추가 (색상은 기존 것 우선)
  if (newLegend.traits) {
    for (const [key, item] of Object.entries(newLegend.traits)) {
      if (!merged.traits[key]) {
        merged.traits[key] = item;
      }
      // 기존 트레이트는 색상 유지 (count는 나중에 재계산)
    }
  }
  
  // 새로운 Rule들 추가 (색상은 기존 것 우선)
  if (newLegend.rules) {
    for (const [key, item] of Object.entries(newLegend.rules)) {
      if (!merged.rules[key]) {
        merged.rules[key] = item;
      }
    }
  }
  
  return merged;
}

// 현재 그래프 상태를 기반으로 범례 카운트 재계산
function recalculateLegendCounts(legend, nodes, edges) {
  const updated = {
    traits: { ...legend.traits },
    rules: {}
  };
  
  // 모든 카운트 초기화
  Object.keys(updated.traits).forEach(key => {
    updated.traits[key] = { ...updated.traits[key], count: 0 };
  });
  
  // 엣지에서 트레이트 카운트 계산
  edges.forEach(edge => {
    const traitKey = String(edge.traitCode || 0);
    if (updated.traits[traitKey]) {
      updated.traits[traitKey].count++;
    }
  });
  
  // Rule 범례 보존 및 카운트 계산 (기존 색상/이름 유지)
  const ruleCount = {};
  console.log('=== Rule Legend Debug ===');
  console.log(`Total nodes to process: ${nodes.length}`);
  
  // 기존 Rule 범례 복사 (색상과 이름 보존)
  if (legend.rules) {
    Object.keys(legend.rules).forEach(ruleId => {
      updated.rules[ruleId] = { 
        ...legend.rules[ruleId], 
        count: 0 
      };
    });
  }
  
  nodes.forEach((node, index) => {
    console.log(`Node ${index}:`, node.id, 'traits:', node.traits?.length || 0);
    
    // 노드의 traits에서 실제 RuleCode 추출 - 더 견고한 검증
    if (node.traits && Array.isArray(node.traits)) {
      // 각 노드에 대해 해당 노드가 가진 Rule들을 수집
      const nodeRules = new Set();
      
      node.traits.forEach((trait, traitIndex) => {
        console.log(`  Trait ${traitIndex}:`, trait);
        
        // ruleCode 속성 확인 - 다양한 형태 지원
        let ruleCode = null;
        if (trait.ruleCode !== undefined && trait.ruleCode !== null) {
          ruleCode = trait.ruleCode;
        } else if (trait.RuleCode !== undefined && trait.RuleCode !== null) {
          ruleCode = trait.RuleCode;
        } else if (trait.rule_code !== undefined && trait.rule_code !== null) {
          ruleCode = trait.rule_code;
        }
        
        console.log(`    TraitCode: ${trait.traitCode}, RuleCode: ${ruleCode}`);
        
        // 유효한 ruleCode인지 확인 (0보다 크고 숫자여야 함)
        if (ruleCode !== null && ruleCode !== undefined && ruleCode > 0) {
          const numericRuleCode = Number(ruleCode);
          if (!isNaN(numericRuleCode) && numericRuleCode > 0) {
            nodeRules.add(numericRuleCode);
            console.log(`    Added rule: ${numericRuleCode}`);
          } else {
            console.log(`    Invalid rule code: ${ruleCode} (not a positive number)`);
          }
        } else {
          console.log(`    No valid rule code found for trait ${trait.traitCode}`);
        }
      });
      
      console.log(`  Node ${node.id} total unique rules: ${nodeRules.size}`, Array.from(nodeRules));
      
      // 실제 RuleCode들을 범례에 추가 (기존 색상/이름 우선)
      nodeRules.forEach(ruleCode => {
        const ruleKey = String(ruleCode);
        if (!updated.rules[ruleKey]) {
          // 새로운 룰이면 새로 생성
          updated.rules[ruleKey] = {
            count: 0,
            name: `Rule ${ruleCode}`, // 백엔드에서 실제 이름 받아올 때까지 임시
            color: generateRuleColor(ruleCode)
          };
          console.log(`    Created new rule legend: ${ruleKey}`);
        }
        updated.rules[ruleKey].count++;
        console.log(`    Incremented count for rule ${ruleKey}: ${updated.rules[ruleKey].count}`);
      });
    } else {
      console.log(`  Node ${node.id} has no traits or invalid traits array`);
    }
  });
  
  console.log('Final updated rules:', updated.rules);
  
  return updated;
}
function renderLegend(legend){
  const t = document.getElementById('traitLegend');
  const r = document.getElementById('ruleLegend');
  t.innerHTML = '';
  r.innerHTML = '';
  
  // 클릭 가능한 트레이트 범례 항목 생성
  const mkTrait = (color,name,count,traitCode)=>`<div class="legend-item" data-trait="${traitCode||''}" style="cursor:pointer;padding:4px;border-radius:4px;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background=''"onclick="toggleTraitHighlight('${traitCode||''}','${color}')"><div class="legend-color" style="background:${color}"></div><span>${name} <small style="color:#888;">(${traitCode})</small></span><span style="margin-left:auto;color:#888;font-size:11px">${count}</span></div>`;
  
  // 클릭 가능한 룰 범례 항목 생성
  const mkRule = (color,name,count,ruleId)=>`<div class="legend-item" data-rule="${ruleId||''}" style="cursor:pointer;padding:4px;border-radius:4px;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background=''"onclick="toggleRuleHighlight('${ruleId||''}','${color}')"><div class="legend-color" style="background:${color}"></div><span>${name} <small style="color:#888;">(${ruleId})</small></span><span style="margin-left:auto;color:#888;font-size:11px">${count}</span></div>`;
  
  // Multi-Trait 항목을 맨 위에 추가 (실제 멀티 트레이트 연결된 노드 수 계산)
  let multiTraitNodes = new Set();
  // CURRENT 그래프에서 parallelCount > 1인 엣지들의 노드들을 수집
  if (CURRENT && CURRENT.edges) {
    CURRENT.edges.forEach(edge => {
      const cnt = edge.parallelCount || 1;
      if (cnt > 1) {
        multiTraitNodes.add(edge.source);
        multiTraitNodes.add(edge.target);
      }
    });
  }
  const multiTraitCount = multiTraitNodes.size;
  t.insertAdjacentHTML('beforeend', mkTrait('#000000', 'Multi-Trait', multiTraitCount, 'multi'));
  
  // 기존 트레이트들
  for (const k in (legend.traits||{})) {
    const it = legend.traits[k]; 
    t.insertAdjacentHTML('beforeend', mkTrait(it.color, it.name, it.count||0, k));
  }
  
  // Rule 범례들
  for (const k in (legend.rules||{})) {
    const it = legend.rules[k]; 
    r.insertAdjacentHTML('beforeend', mkRule(it.color, it.name, it.count||0, k));
  }
}

// PolyTrait 색상 생성 함수
function generatePolyTraitColor(polyTraitCode) {
  // PolyTrait별로 고유한 색상 생성 (더 밝고 눈에 띄는 색상)
  const h = (polyTraitCode * 73 + 180) % 360;  // 73은 소수
  const s = 80 + (polyTraitCode % 2) * 10;     // 80-90% 채도 (더 선명하게)
  const l = 50 + (polyTraitCode % 3) * 10;     // 50-70% 명도 (더 밝게)
  return `hsl(${h}, ${s}%, ${l}%)`;
}

// PolyTrait 범례 데이터 로드
function loadPolyTraitLegend() {
  console.log('=== Loading PolyTrait legend from server ===');
  
  const url = '/api/triplet/graph/polytrait/legend';
  console.log('Fetching URL:', url);
  
  fetch(url)
    .then(response => {
      console.log('PolyTrait legend response status:', response.status);
      console.log('PolyTrait legend response ok:', response.ok);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response.json();
    })
    .then(legend => {
      console.log('=== PolyTrait legend loaded successfully ===');
      console.log('Raw server response:', legend);
      console.log('Legend keys:', Object.keys(legend));
      
      if (!legend || Object.keys(legend).length === 0) {
        console.warn('PolyTrait legend is empty or null');
        return;
      }
      
      polyTraitLegendData = legend;
      
      // 색상 추가 및 데이터 정규화 (서버에서 색상을 제공하지 않는 경우)
      for (const [code, info] of Object.entries(legend)) {
        console.log(`Processing PolyTrait ${code}:`, info);
        
        // 서버 응답의 Name을 name으로 정규화
        if (info.Name && !info.name) {
          info.name = info.Name;
        }
        
        if (!info.color) {
          info.color = generatePolyTraitColor(parseInt(code));
          console.log(`Generated color for ${code}:`, info.color);
        }
        
        console.log(`PolyTrait ${code} processed:`, {name: info.name, color: info.color});
      }
      
      console.log('Final polyTraitLegendData:', polyTraitLegendData);
      renderPolyTraitLegend();
    })
    .catch(err => {
      console.error('=== Failed to load PolyTrait legend ===');
      console.error('Error details:', err);
      console.error('Error message:', err.message);
      
      // 에러시 빈 범례 표시
      polyTraitLegendData = {};
      renderPolyTraitLegend();
    });
}

// PolyTrait 범례 렌더링
function renderPolyTraitLegend() {
  console.log('=== Rendering PolyTrait legend ===');
  
  const pt = document.getElementById('polyTraitLegend');
  if (!pt) {
    console.error('PolyTrait legend container not found');
    return;
  }
  
  console.log('PolyTrait legend container found');
  console.log('polyTraitLegendData entries:', Object.keys(polyTraitLegendData).length);
  
  pt.innerHTML = '';
  
  if (Object.keys(polyTraitLegendData).length === 0) {
    console.log('No PolyTrait data to render');
    pt.innerHTML = '<div style="color:#888;font-style:italic;">No PolyTraits available</div>';
    return;
  }
  
  // 클릭 가능한 PolyTrait 범례 항목 생성
  const mkPolyTrait = (color, name, polyTraitCode, traitCodes) => `<div class="legend-item" data-polytrait="${polyTraitCode||''}" style="cursor:pointer;padding:4px;border-radius:4px;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background=''" onclick="togglePolyTraitHighlight('${polyTraitCode||''}','${color}')"><div class="legend-color" style="background:${color}"></div><span>${name} <small style="color:#888;">(${polyTraitCode}) [${traitCodes}]</small></span></div>`;
  
  // PolyTrait 범례들
  let renderedCount = 0;
  for (const [code, info] of Object.entries(polyTraitLegendData)) {
    const color = info.color || generatePolyTraitColor(parseInt(code));
    const name = info.name || `PolyTrait ${code}`;
    const traits = info.Traits || info.traits || [];
    const traitCodes = traits.join(', ');
    
    console.log(`Rendering PolyTrait ${code}: ${name} (${color}) with traits: [${traitCodes}]`);
    pt.insertAdjacentHTML('beforeend', mkPolyTrait(color, name, code, traitCodes));
    renderedCount++;
  }
  
  console.log(`Successfully rendered ${renderedCount} PolyTrait legend items`);
}

// PolyRope 검색 결과 표시 함수
function showPolyRopeResult(result) {
  const panel = document.getElementById('polyRopeResultPanel');
  const content = document.getElementById('polyRopeResultContent');
  
  if (!result) {
    panel.style.display = 'none';
    return;
  }
  
  let html = '';
  html += '<div><b>Address 1:</b> ' + (result.address1 ? result.address1.substring(0, 10) + '...' : 'N/A') + '</div>';
  html += '<div><b>Address 2:</b> ' + (result.address2 ? result.address2.substring(0, 10) + '...' : 'N/A') + '</div>';
  html += '<div><b>PolyTrait:</b> ' + (result.polytraitcode || 'N/A') + '</div>';
  html += '<div><b>Connected:</b> <span style="color:' + (result.in_same_rope ? '#28a745' : '#dc3545') + ';font-weight:bold;">' + (result.in_same_rope ? '✅ YES' : '❌ NO') + '</span></div>';
  
  if (polyTraitLegendData[result.polytraitcode]) {
    html += '<div><b>PolyTrait Name:</b> ' + polyTraitLegendData[result.polytraitcode].name + '</div>';
  }
  
  content.innerHTML = html;
  panel.style.display = 'block';
}

function hidePolyRopeResult() {
  const panel = document.getElementById('polyRopeResultPanel');
  panel.style.display = 'none';
}

// 하이라이팅 상태 관리
let currentHighlightTrait = null;
let currentHighlightRule = null;

function toggleTraitHighlight(traitCode, color) {
  if (currentHighlightTrait === traitCode) {
    // 이미 선택된 트레이트면 하이라이팅 해제
    currentHighlightTrait = null;
    f.contentWindow.postMessage({type: 'highlight-trait', payload: {traitCode: null}}, '*');
  } else {
    // 새로운 트레이트 하이라이팅
    currentHighlightTrait = traitCode;
    f.contentWindow.postMessage({type: 'highlight-trait', payload: {traitCode, color}}, '*');
  }
}

function toggleRuleHighlight(ruleId, color) {
  // 우선순위 제약 제거 - 트레이트 하이라이팅 상태와 무관하게 작동
  if (currentHighlightRule === ruleId) {
    // 이미 선택된 Rule이면 하이라이팅 해제
    currentHighlightRule = null;
    f.contentWindow.postMessage({type: 'highlight-rule', payload: {ruleId: null}}, '*');
  } else {
    // 새로운 Rule 하이라이팅
    currentHighlightRule = ruleId;
    f.contentWindow.postMessage({type: 'highlight-rule', payload: {ruleId, color}}, '*');
  }
}

function getCurrentRuleColor(ruleId) {
  if (CURRENT && CURRENT.legend && CURRENT.legend.rules && CURRENT.legend.rules[ruleId]) {
    return CURRENT.legend.rules[ruleId].color;
  }
  return generateRuleColor(ruleId);
}

// Trait 하이라이팅만 해제
function recoverTrait() {
  console.log('Recovering trait highlighting...');
  
  // Trait 하이라이팅 상태만 초기화
  currentHighlightTrait = null;
  
  // 프레임에 Trait 해제 신호 전송
  f.contentWindow.postMessage({type: 'highlight-trait', payload: {traitCode: null}}, '*');
  
  // 알림 표시
  showNotification('Trait 하이라이팅이 해제되었습니다', 'info');
}

// Rule 하이라이팅만 해제
function recoverRule() {
  console.log('Recovering rule highlighting...');
  
  // Rule 하이라이팅 상태만 초기화
  currentHighlightRule = null;
  
  // 프레임에 Rule 해제 신호 전송
  f.contentWindow.postMessage({type: 'highlight-rule', payload: {ruleId: null}}, '*');
  
  // 알림 표시
  showNotification('Rule 하이라이팅이 해제되었습니다', 'info');
}

function togglePolyTraitHighlight(polyTraitCode, color) {
  console.log('=== togglePolyTraitHighlight called ===');
  console.log('Input polyTraitCode:', polyTraitCode);
  console.log('Input color:', color);
  console.log('Current currentHighlightPolyTrait:', currentHighlightPolyTrait);
  
  if (currentHighlightPolyTrait === polyTraitCode) {
    // 이미 선택된 PolyTrait면 하이라이팅 해제
    console.log('Disabling PolyTrait highlight');
    currentHighlightPolyTrait = null;
    f.contentWindow.postMessage({type: 'highlight-polytrait', payload: {polyTraitCode: null}}, '*');
  } else {
    // 새로운 PolyTrait 하이라이팅
    console.log('Enabling PolyTrait highlight');
    currentHighlightPolyTrait = polyTraitCode;
    
    // PolyTrait 데이터도 함께 전달 (전체 legend 데이터를 전달)
    console.log('Sending complete PolyTrait legend data to frame');
    console.log('polyTraitLegendData keys:', Object.keys(polyTraitLegendData));
    console.log('Target polyTraitCode:', polyTraitCode);
    
    f.contentWindow.postMessage({
      type: 'highlight-polytrait', 
      payload: {
        polyTraitCode, 
        color,
        polyTraitData: polyTraitLegendData
      }
    }, '*');
  }
}

// PolyTrait 하이라이팅만 해제
function recoverPolyTrait() {
  console.log('Recovering PolyTrait highlighting...');
  
  // PolyTrait 하이라이팅 상태만 초기화
  currentHighlightPolyTrait = null;
  
  // 프레임에 PolyTrait 해제 신호 전송
  f.contentWindow.postMessage({type: 'highlight-polytrait', payload: {polyTraitCode: null}}, '*');
  
  // 알림 표시
  showNotification('PolyTrait 하이라이팅이 해제되었습니다', 'info');
}

// 메시지(자식 → 부모)
window.addEventListener('message', (ev)=>{
  const msg = ev.data||{};
  if (msg.type==='child-mounted'){
    // 초기 로드
    fetch('/api/triplet/graph/default').then(r=>r.json()).then(g=>{
      CURRENT = g; syncStats(CURRENT); renderLegend(CURRENT.legend||{traits:{}, rules:{}});
      resetInfoPanel(); // Info 패널 초기화
      hideRopeInfo(); // 로프 정보 숨김
      hidePolyRopeResult(); // PolyRope 검색 결과 숨김
      loadPolyTraitLegend(); // PolyTrait 범례 로드
      f.contentWindow.postMessage({type:'load-graph', payload: CURRENT}, '*');
    });
  } else if (msg.type==='child-ready'){
    // ok 여부만 확인 가능
  } else if (msg.type==='node-hover'){
    // Payload가 없으면 정보를 유지 (마우스가 leave해도 계속 표시)
    if (!msg.payload) { return; }
    
    console.log('Received node-hover payload:', msg.payload);
    console.log('ropes array:', msg.payload.ropes);
    console.log('ropeId:', msg.payload.ropeId);
    console.log('ropeCount:', msg.payload.ropeCount);
    
    nodeBox.classList.remove('muted');
    const p = msg.payload;
    
    // 기본 정보
    let html = 'Address: <span class="mono">' + (p.id || '') + '</span>';
    
    // 로프 정보 - 모든 로프 ID를 표시
    console.log('Checking if ropeCount > 0:', p.ropeCount, '>', 0, '=', p.ropeCount > 0);
    if (p.ropeCount > 0) {
      html += '<br/>Ropes: <b>' + p.ropeCount + '</b>';
      
      console.log('Checking ropes condition:');
      console.log('p.ropes:', p.ropes);
      console.log('p.ropes.length:', p.ropes ? p.ropes.length : 'undefined');
      console.log('p.ropeId:', p.ropeId);
      
      // 모든 로프 ID 표시
      if (p.ropes && p.ropes.length > 0) {
        console.log('Using ropes array');
        // ropes 배열이 있는 경우 모든 ID 표시
        html += '<br/>IDs: ';
        const ropeIds = p.ropes.map(rope => '#' + rope.id).join(', ');
        html += '<span class="mono">' + ropeIds + '</span>';
        console.log('Generated ropeIds:', ropeIds);
      } else if (p.ropeId && p.ropeId !== 0) {
        console.log('Using fallback ropeId');
        // 기존 방식 호환성 (ropes 배열이 없는 경우) - 최소한 primary ID는 표시
        html += '<br/>IDs: <span class="mono">#' + p.ropeId + '</span>';
      } else {
        console.log('No rope IDs to display');
      }
    }
    
    // 트레이트 정보
    if (p.traitCount > 0) {
      html += '<br/>Traits: <b>' + p.traitCount + '</b>';
      if (p.traits && p.traits.length > 0) {
        html += '<br/>Types: ';
        const traitNames = p.traits.slice(0, 3).map(t => t.traitName || 'code ' + t.traitCode).join(', ');
        html += '<span class="muted">' + traitNames;
        if (p.traits.length > 3) {
          html += ' +' + (p.traits.length - 3) + ' more';
        }
        html += '</span>';
      }
    }
    
    // 정보가 없을 경우
    if (p.ropeCount === 0 && p.traitCount === 0) {
      html += '<br/><span class="muted">No connections</span>';
    }
    
    nodeBox.innerHTML = html;
  } else if (msg.type==='edge-hover'){
    // Payload가 없으면 정보를 유지 (마우스가 leave해도 계속 표시)
    if (!msg.payload) { return; }
    edgeBox.classList.remove('muted');
    const p = msg.payload;
    
    if (p.isMultiTrait && p.traits) {
      // 멀티 트레이트 정보 표시
      let html = '<b>Multi-Trait Connection (' + p.totalTraits + ' traits):</b><br/>';
      p.traits.forEach((trait, index) => {
        html += (index > 0 ? '<br/>' : '') + 
                '• <b>' + (trait.traitName || ('code ' + trait.traitCode)) + '</b> ' +
                '<span class="mono">#' + (trait.traitId || 0) + '</span>';
      });
      edgeBox.innerHTML = html;
    } else {
      // 단일 트레이트 정보 표시
      edgeBox.innerHTML = 'Trait: <b>'+(p.traitName||('code '+p.traitCode))+'</b> <span class="mono">#'+(p.traitId||0)+'</span>';
    }
  } else if (msg.type==='node-click'){
    const id = msg.payload && msg.payload.id;
    if (!id) return;
    
    // 노드 확장 확인 대화상자
    const shortId = id.length > 10 ? id.substr(0, 6) + '..' + id.substr(-4) : id;
    const confirmExpand = confirm(`노드 "${shortId}"를 1-hop 확장하시겠습니까?\n\n연결된 노드들이 그래프에 추가됩니다.`);
    
    if (confirmExpand) {
      console.log(`=== NODE EXPANSION (PURE DB MODE): ${shortId} ===`);
      
      fetch('/api/triplet/graph/expand?v='+encodeURIComponent(id))
        .then(r=>r.json()).then(expandResult=>{
          console.log('Pure DB expansion result:', {
            nodes: expandResult.nodes?.length || 0,
            edges: expandResult.edges?.length || 0,
            error: expandResult.error
          });
          
          if (expandResult.error) {
            console.error(`Expansion failed: ${expandResult.error}`);
            alert('노드 확장에 실패했습니다: ' + expandResult.error);
            return;
          }
          
          // 기존 그래프에 확장 결과 추가 (apply-graph 사용)
          console.log('Adding expansion results to existing graph');
          
          // 업데이트 전에 기존 노드/엣지 ID 저장 (비교용)
          const existingNodeIds = new Set((CURRENT.nodes || []).map(n => n.id));
          const existingEdgeIds = new Set((CURRENT.edges || []).map(e => e.id));
          
          // 실제로 새로 추가될 노드와 엣지 미리 계산
          const trulyNewNodes = (expandResult.nodes || []).filter(n => !existingNodeIds.has(n.id));
          const trulyNewEdges = (expandResult.edges || []).filter(e => !existingEdgeIds.has(e.id));
          
          console.log('Truly new elements:', {
            newNodes: trulyNewNodes.length,
            newEdges: trulyNewEdges.length,
            existingNodes: existingNodeIds.size,
            existingEdges: existingEdgeIds.size
          });
          
          // CURRENT에 새로운 노드와 엣지 추가 (브라우저 상태 동기화)
          const nodeMap = new Map();
          const edgeMap = new Map();
          
          // 기존 노드/엣지 추가
          (CURRENT.nodes || []).forEach(n => nodeMap.set(n.id, n));
          (CURRENT.edges || []).forEach(e => edgeMap.set(e.id, e));
          
          // 확장 결과 노드/엣지 추가
          (expandResult.nodes || []).forEach(n => nodeMap.set(n.id, n));
          (expandResult.edges || []).forEach(e => edgeMap.set(e.id, e));
          
          // CURRENT 업데이트
          CURRENT.nodes = [...nodeMap.values()];
          CURRENT.edges = [...edgeMap.values()];
          CURRENT.meta = {
            ...CURRENT.meta,
            nodeCount: CURRENT.nodes.length,
            edgeCount: CURRENT.edges.length,
            generatedAt: Math.floor(Date.now()/1000)
          };
          
          // 범례 병합 및 재계산 (기존 범례 색상을 유지하면서 새로운 데이터 추가 후 카운트 재계산)
          if (expandResult.legend) {
            // 1단계: 범례 병합 (색상 일관성 유지)
            CURRENT.legend = mergeLegends(CURRENT.legend || {traits:{}, rules:{}}, expandResult.legend);
            // 2단계: 현재 그래프 상태 기반으로 카운트 재계산
            CURRENT.legend = recalculateLegendCounts(CURRENT.legend, CURRENT.nodes, CURRENT.edges);
          }
          
          console.log('Graph expansion completed:', { 
            before: { nodes: existingNodeIds.size, edges: existingEdgeIds.size },
            received: { nodes: expandResult.nodes?.length || 0, edges: expandResult.edges?.length || 0 },
            added: { nodes: trulyNewNodes.length, edges: trulyNewEdges.length },
            after: { nodes: CURRENT.nodes.length, edges: CURRENT.edges.length }
          });
          
          const addedNodes = trulyNewNodes.length;
          const addedEdges = trulyNewEdges.length;
          
          // 확장 결과 알림 메시지 생성
          if (addedNodes > 0 || addedEdges > 0) {
            let notificationMsg = `✅ 확장 완료: ${addedNodes}개 노드, ${addedEdges}개 연결 추가`;
            
            // 실제로 추가된 노드 주소 표시 (최대 3개)
            if (trulyNewNodes.length > 0) {
              const newAddresses = trulyNewNodes
                .filter(n => n.id !== id) // 클릭한 노드 제외
                .slice(0, 3)
                .map(n => {
                  const addr = n.id;
                  return addr.length > 10 ? addr.substr(0, 6) + '..' + addr.substr(-4) : addr;
                });
              
              if (newAddresses.length > 0) {
                notificationMsg += '<br/>새 노드: ' + newAddresses.join(', ');
                const remainingCount = trulyNewNodes.filter(n => n.id !== id).length - 3;
                if (remainingCount > 0) {
                  notificationMsg += ` 외 ${remainingCount}개`;
                }
              }
            }
            
            showNotification(notificationMsg, 2500);
          } else {
            showNotification('ℹ️ 이미 모든 연결이 표시되고 있습니다', 2000);
          }
          
          syncStats(CURRENT); 
          renderLegend(CURRENT.legend||{traits:{}, rules:{}});
          
          // 프레임에 증분 데이터와 함께 업데이트된 범례 전송
          const incrementalUpdate = {
            ...expandResult,
            legend: CURRENT.legend  // 병합된 범례 사용
          };
          f.contentWindow.postMessage({type:'apply-graph', payload: incrementalUpdate}, '*');
          console.log(`Pure DB expansion completed: ${shortId} (${CURRENT.nodes?.length || 0} nodes, ${CURRENT.edges?.length || 0} edges)`);
        })
        .catch(err => {
          console.error(`Failed to expand node ${shortId}:`, err);
          alert('노드 확장에 실패했습니다. 다시 시도해주세요.');
        });
    }
  }
});

// 검색 버튼 → 서버 호출
document.getElementById('defBtn').onclick = ()=>{
  console.log('Default button clicked');
  fetch('/api/triplet/graph/default').then(r=>r.json()).then(g=>{
    CURRENT = g; syncStats(CURRENT); renderLegend(CURRENT.legend||{traits:{}, rules:{}});
    resetInfoPanel(); // Info 패널 초기화
    hideRopeInfo(); // 로프 정보 숨김
    hidePolyRopeResult(); // PolyRope 검색 결과 숨김
    loadPolyTraitLegend(); // PolyTrait 범례 다시 로드
    f.contentWindow.postMessage({type:'load-graph', payload: CURRENT}, '*');
  });
};

// 버튼 이벤트 등록 확인
console.log('=== BUTTON EVENT REGISTRATION ===');
console.log('addrBtn element:', document.getElementById('addrBtn'));
console.log('ropeBtn element:', document.getElementById('ropeBtn'));
console.log('defBtn element:', document.getElementById('defBtn'));
console.log('=== EVENT HANDLERS REGISTERED ===');
// 주소 검색: 해당 주소를 중심으로 그래프 초기화 + 1-hop 확장
document.getElementById('addrBtn').onclick = ()=>{
  console.log('=== ADDRESS SEARCH (RESET MODE) ===');
  const addr = (document.getElementById('addr').value||'').trim();
  console.log('Searching address:', addr);
  
  if (!addr) {
    return alert('주소를 입력해주세요 (예: 0x1234...)');
  }
  
  const url = '/api/triplet/graph/expand?v='+encodeURIComponent(addr);
  console.log('Request URL:', url);
  
  fetch(url)
    .then(r => r.json())
    .then(searchResult => {
      console.log('Search result:', {
        nodes: searchResult.nodes?.length || 0,
        edges: searchResult.edges?.length || 0,
        error: searchResult.error
      });
      
      if (searchResult.error) {
        alert('주소 검색 실패: ' + searchResult.error);
        return;
      }
      
      // 그래프 완전 초기화 (DB 결과로 완전 대체, 병합 없음)
      console.log('Replacing current graph with pure DB search results (no merge)');
      CURRENT = searchResult;
      
      // 그래프 메타 정보 설정
      CURRENT.meta = {
        ...CURRENT.meta,
        generatedAt: Math.floor(Date.now()/1000),
        graphType: 'search-address',
        startNode: addr
      };
      
      syncStats(CURRENT); 
      renderLegend(CURRENT.legend||{traits:{}, rules:{}});
      resetInfoPanel(); // Info 패널 초기화
      hideRopeInfo(); // 로프 정보 숨김
      
      // iframe 새로고침 없이 그래프만 완전 리셋 후 새 데이터 로드
      console.log('=== RESETTING GRAPH WITHOUT IFRAME RELOAD ===');
      console.log('New search graph data:', CURRENT);
      
      // load-graph 메시지로 완전한 그래프 교체 수행
      f.contentWindow.postMessage({type:'load-graph', payload: CURRENT}, '*');
      
      console.log(`Address search completed: ${addr} (${CURRENT.nodes?.length || 0} nodes, ${CURRENT.edges?.length || 0} edges)`);
    })
    .catch(err => {
      console.error('Address search error:', err);
      alert('주소 검색 중 오류가 발생했습니다: ' + err.message);
    });
};

// Rope 검색: 해당 Rope를 중심으로 그래프 초기화 (완전히 DB 기반, 병합 없음)
document.getElementById('ropeBtn').onclick = ()=>{
  const ropeId = (document.getElementById('rope').value||'').trim();
  if (!ropeId) return alert('Rope ID를 입력해주세요 (예: 1, 2, 3)');
  
  console.log(`=== ROPE SEARCH (PURE DB MODE): ${ropeId} ===`);
  
  // 단일 DB 호출: FetchGraphByRopeID는 이미 rope 멤버들 + 1-hop 확장을 DB에서 계산함 (depth=2)
  const url = '/api/triplet/graph/rope/'+encodeURIComponent(ropeId);
  console.log('Request URL:', url);
  
  fetch(url)
    .then(r => r.json())
    .then(searchResult => {
      console.log('Pure DB rope search result:', {
        nodes: searchResult.nodes?.length || 0,
        edges: searchResult.edges?.length || 0,
        error: searchResult.error
      });
      
      if (searchResult.error) {
        alert('Rope 검색 실패: ' + searchResult.error);
        return;
      }
      
      // 그래프 완전 초기화 (순수 DB 결과, 브라우저 상태 병합 없음)
      console.log('Replacing current graph with pure DB rope results (no browser merging)');
      CURRENT = searchResult;
      
      // 그래프 메타 정보 설정
      CURRENT.meta = {
        ...CURRENT.meta,
        generatedAt: Math.floor(Date.now()/1000),
        graphType: 'search-rope',
        startNode: `Rope ${ropeId}`
      };
      
      syncStats(CURRENT);
      renderLegend(CURRENT.legend||{traits:{}, rules:{}});
      resetInfoPanel(); // Info 패널 초기화
      
      // iframe 새로고침 없이 그래프만 완전 리셋 후 새 데이터 로드
      console.log('=== RESETTING ROPE GRAPH WITHOUT IFRAME RELOAD ===');
      console.log('Pure DB rope graph data:', CURRENT);
      
      // load-graph 메시지로 완전한 그래프 교체 수행
      f.contentWindow.postMessage({type:'load-graph', payload: CURRENT}, '*');
      
      // 로프 정보 로드
      loadRopeInfo(ropeId);
      
      console.log(`Pure DB rope search completed: ${ropeId} (${CURRENT.nodes?.length || 0} nodes, ${CURRENT.edges?.length || 0} edges)`);
    })
    .catch(err => {
      console.error('Rope search error:', err);
      alert('Rope 검색 중 오류가 발생했습니다: ' + err.message);
    });
};

// PolyRope 검색
document.getElementById('polyRopeBtn').onclick = ()=>{
  const addr1 = (document.getElementById('polyAddr1').value||'').trim();
  const addr2 = (document.getElementById('polyAddr2').value||'').trim();
  const polyTraitCode = (document.getElementById('polyTraitCode').value||'').trim();
  
  if (!addr1 || !addr2 || !polyTraitCode) {
    return alert('모든 필드를 입력해주세요 (Address 1, Address 2, PolyTrait Code)');
  }
  
  console.log(`=== POLYROPE SEARCH ===`, {addr1, addr2, polyTraitCode});
  
  const url = '/api/triplet/graph/polyrope/search?address1=' + encodeURIComponent(addr1) + '&address2=' + encodeURIComponent(addr2) + '&polytraitcode=' + encodeURIComponent(polyTraitCode);
  console.log('Request URL:', url);
  
  fetch(url)
    .then(r => r.json())
    .then(result => {
      console.log('PolyRope search result:', result);
      
      if (result.error) {
        alert('PolyRope 검색 실패: ' + result.error);
        hidePolyRopeResult();
        return;
      }
      
      // 검색 결과 표시
      showPolyRopeResult(result);
      
      // 성공 알림
      const connected = result.in_same_rope ? '연결됨' : '연결 안됨';
      showNotification(`🔗 PolyRope 검색 완료: ${connected}`, 2000);
    })
    .catch(err => {
      console.error('PolyRope search error:', err);
      alert('PolyRope 검색 중 오류가 발생했습니다: ' + err.message);
      hidePolyRopeResult();
    });
};
</script>
</body>
</html>
