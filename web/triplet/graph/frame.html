<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Rope Graph Frame</title>
  <style>
    html,body{
      height:100%; margin:0;
      overflow:hidden; scrollbar-gutter: stable both-edges; overscroll-behavior:none;
    }
    #container{ position:absolute; inset:0; overflow:hidden; touch-action:none; user-select:none }
    canvas{ display:block }
    #hud{
      position:absolute; top:10px; left:10px; z-index:10;
      background:rgba(255,255,255,.92); padding:8px 10px; border-radius:10px;
      font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Noto Sans,Arial;
      box-shadow:0 2px 10px rgba(0,0,0,.08)
    }
    #hud code{ padding:2px 6px; background:#eee; border-radius:6px }
    
    
    /* 노드 드래그 커서 */
    .dragging-node {
      cursor: move !important;
    }
    
    .hovering-node {
      cursor: grab !important;
    }
  </style>
  <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.min.js"></script>
  <script src="https://unpkg.com/sigma@2.4.0/build/sigma.min.js"></script>
</head>
<body>
  <div id="hud"><strong>Rope Graph</strong>
    <div>nodes: <code id="ncount">0</code> | edges: <code id="ecount">0</code></div>
  </div>
  <div id="container"></div>
</body>

<script>
(function(){
  const SigmaCtor = (window && (window.Sigma || (window.sigma && window.sigma.Sigma))) || null;
  const GraphologyGraph = (window && window.graphology && window.graphology.Graph) ? window.graphology.Graph : null;

  let GRAPH = null, RENDERER = null, DATA = null;
  let TRAIT_PALETTE = {};
  let isHighlighted = false;  // 하이라이팅 상태를 전역으로 이동
  let currentTraitHighlight = null;  // 현재 활성화된 트레이트 하이라이팅 {code, color}
  let currentRuleHighlight = null;   // 현재 활성화된 룰 하이라이팅 {id, color}
  let currentPolyTraitHighlight = null;  // 현재 활성화된 PolyTrait 하이라이팅 {code, color}
  
  // 더블클릭 관련 변수들
  let hoveredNode = null;
  let lastClickTime = 0;
  let lastClickedNode = null;

  // ===== Color helpers =====
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function hslToHex(h, s, l){
    h = ((h%360)+360)%360; s = clamp01(s/100); l = clamp01(l/100);
    const c = (1 - Math.abs(2*l - 1)) * s, hp = h/60, x = c*(1 - Math.abs((hp%2)-1));
    let r=0,g=0,b=0;
    if (0<=hp && hp<1){ r=c; g=x; } else if (1<=hp && hp<2){ r=x; g=c; }
    else if (2<=hp && hp<3){ g=c; b=x; } else if (3<=hp && hp<4){ g=x; b=c; }
    else if (4<=hp && hp<5){ r=x; b=c; } else if (5<=hp && hp<6){ r=c; b=x; }
    const m = l - c/2; r = Math.round((r+m)*255); g = Math.round((g+m)*255); b = Math.round((b+m)*255);
    const toHex=n=>n.toString(16).padStart(2,'0'); return '#'+toHex(r)+toHex(g)+toHex(b);
  }
  function parseColorToHex(c){
    if (!c) return '#9aa0a6';
    if (c[0] === '#') return c;
    const s = String(c).trim();
    let m = /^hsl\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%\s*\)$/i.exec(s);
    if (m) return hslToHex(parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]));
    m = /^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i.exec(s);
    if (m){
      const r = Math.max(0, Math.min(255, parseInt(m[1],10)));
      const g = Math.max(0, Math.min(255, parseInt(m[2],10)));
      const b = Math.max(0, Math.min(255, parseInt(m[3],10)));
      const toHex=n=>n.toString(16).padStart(2,'0'); return '#'+toHex(r)+toHex(g)+toHex(b);
    }
    return '#9aa0a6';
  }
  function buildTraitPaletteFromLegend() {
    const pal = {};
    try {
      const L = DATA && DATA.legend && DATA.legend.traits ? DATA.legend.traits : {};
      Object.keys(L).forEach(k=>{
        const key = Number(k); const item = L[k] || {};
        if (key === 0 && !item.color) return;
        pal[key] = parseColorToHex(item.color || '#9aa0a6');
      });
    } catch (_){}
    return pal;
  }
  function traitColorFromLegend(tc, fallback) {
    const c = TRAIT_PALETTE[tc];
    return c || (fallback ? parseColorToHex(fallback) : null);
  }
  function genTraitColor(code){
    const h = (code * 89 + 180) % 360;
    const s = 65 + (code % 4) * 8;
    const l = 40 + (code % 5) * 5;
    return hslToHex(h, s, l);
  }

  // 오버레이 관련 함수들 제거됨

  // === 굴곡/굵기 튜닝 ===
  const CURVE_MIN = 40;           // 2개 평행일 때도 확실히 휘도록
  const CURVE_SCALE = 0.22;       // 거리 비례 가산
  const WIDTH_BASE = 3.6;         // 굵기 배율(크게)
  const WIDTH_HOVER_BUMP = 1.35;  // 호버시 가산

  // ===== Graph build / merge =====
  function addDataToGraph(data){
    DATA = data;
    TRAIT_PALETTE = buildTraitPaletteFromLegend();

    const NODE_COLOR = '#222222';
    const NODE_LABEL = '#ffffff';

    const nodes = data.nodes || [];
    const edges = data.edges || [];
    
    // 디버깅: 받은 데이터에서 멀티 트레이트 엣지 확인
    console.log('=== Incoming data check ===');
    const multiTraitEdges = edges.filter(e => e.parallelCount && e.parallelCount > 1);
    console.log(`Total edges in data: ${edges.length}, Multi-trait edges: ${multiTraitEdges.length}`);
    if (multiTraitEdges.length > 0) {
      console.log('Sample multi-trait edges:', multiTraitEdges.slice(0, 3));
    }
    
    // 그래프 업데이트 후 이벤트 리스너 재등록 방지를 위한 플래그
    const wasInitialized = RENDERER !== null;

    // 기존 노드들의 위치 정보 수집
    const existingPositions = {};
    if (GRAPH) {
      GRAPH.forEachNode((nodeId) => {
        const attrs = GRAPH.getNodeAttributes(nodeId);
        existingPositions[nodeId] = { x: attrs.x, y: attrs.y };
      });
    }

    // 노드 추가/업데이트
    const newNodes = [];
    nodes.forEach((n,i)=>{
      if (!GRAPH.hasNode(n.id)) {
        newNodes.push(n.id);
        // 새 노드 위치 결정: 초기 로딩이면 _initialX/Y 사용, 아니면 임시 위치
        const x = n._initialX !== undefined ? n._initialX : 0;
        const y = n._initialY !== undefined ? n._initialY : 0;
        
        GRAPH.addNode(n.id, {
          label: n.label || n.id,
          size: Math.max(4, Math.min(16, n.size||8)),
          color: NODE_COLOR,
          labelColor: NODE_LABEL,
          x: x,
          y: y
        });
      } else {
        // 기존 노드는 위치 유지하고 속성만 업데이트
        GRAPH.mergeNodeAttributes(n.id, {
          label: n.label || n.id,
          size: Math.max(4, Math.min(16, n.size||8)),
        });
      }
    });

    // 엣지 추가/업데이트
    const seen = new Set();
    edges.forEach((e)=>{
      if (seen.has(e.id)) return; seen.add(e.id);
      const src = e.source, dst = e.target;
      if (!GRAPH.hasNode(src)) GRAPH.addNode(src, { label: src, size: 6, color: NODE_COLOR, labelColor: NODE_LABEL });
      if (!GRAPH.hasNode(dst)) GRAPH.addNode(dst, { label: dst, size: 6, color: NODE_COLOR, labelColor: NODE_LABEL });

      const tc = Number(e.traitCode) || 0;
      const hex = parseColorToHex(e.color || (traitColorFromLegend(tc, null) || genTraitColor(tc)));

      const attrs = {
        size: Math.max(3, Math.min(9, (e.weight || 3))), // 기본값 UP
        colorHex: hex,
        traitCode: e.traitCode, traitName: e.traitName, traitId: e.traitId, lastSeen: e.lastSeen||0,
        pair: e.pair || [src, dst].sort().join('|'),
        parallelIndex: (typeof e.parallelIndex === 'number') ? e.parallelIndex : 0,
        parallelCount: (typeof e.parallelCount === 'number' && e.parallelCount>0) ? e.parallelCount : 1
      };

      if (GRAPH.hasEdge(e.id)) {
        GRAPH.mergeEdgeAttributes(e.id, attrs);
      } else {
        GRAPH.addEdgeWithKey(e.id, src, dst, attrs);
      }
    });
    
    // 새 노드들을 연결된 기존 노드 주변에 배치
    positionNewNodes(newNodes, edges);
    
    // 기존 렌더러가 있을 때만 이벤트 리스너 상태 유지
    if (wasInitialized && RENDERER) {
      // 이벤트 상태를 일시적으로 재활성화
      setTimeout(() => {
        RENDERER.setSetting('enableEdgeHoverEvents', true);
        RENDERER.setSetting('enableEdgeClickEvents', true);
      }, 50);
    }
  }
  
  // 새 노드들을 원형 기반으로 배치하는 함수
  function positionNewNodes(newNodes, edges) {
    if (!GRAPH || newNodes.length === 0) return;
    
    // 현재 그래프의 반지름 계산
    let maxDistance = 120; // 초기 원형 반지름
    GRAPH.forEachNode(nodeId => {
      if (!newNodes.includes(nodeId)) {
        const attrs = GRAPH.getNodeAttributes(nodeId);
        const distance = Math.sqrt(attrs.x * attrs.x + attrs.y * attrs.y);
        maxDistance = Math.max(maxDistance, distance);
      }
    });
    
    // 새 레이어의 반지름 (기존보다 더 멀리)
    const newRadius = maxDistance + 100;
    
    newNodes.forEach((newNodeId, index) => {
      // 연결된 기존 노드 찾기
      const connectedNodes = [];
      edges.forEach(e => {
        if (e.source === newNodeId && GRAPH.hasNode(e.target) && !newNodes.includes(e.target)) {
          connectedNodes.push(e.target);
        } else if (e.target === newNodeId && GRAPH.hasNode(e.source) && !newNodes.includes(e.source)) {
          connectedNodes.push(e.source);
        }
      });
      
      let newX, newY;
      
      if (connectedNodes.length > 0) {
        // 연결된 노드의 방향을 기준으로 배치
        let avgAngle = 0;
        connectedNodes.forEach(nodeId => {
          const attrs = GRAPH.getNodeAttributes(nodeId);
          const angle = Math.atan2(attrs.y, attrs.x);
          avgAngle += angle;
        });
        avgAngle /= connectedNodes.length;
        
        // 기존 노드 방향으로 확장 (더 큰 각도 변화)
        const angleVariation = (Math.random() - 0.5) * 1.0; // ±30도 정도
        const finalAngle = avgAngle + angleVariation;
        
        newX = Math.cos(finalAngle) * newRadius;
        newY = Math.sin(finalAngle) * newRadius;
      } else {
        // 연결된 노드가 없으면 균등하게 배치
        const angle = (2 * Math.PI * index) / newNodes.length;
        newX = Math.cos(angle) * newRadius;
        newY = Math.sin(angle) * newRadius;
      }
      
      // 새 노드 위치 설정
      GRAPH.setNodeAttribute(newNodeId, 'x', newX);
      GRAPH.setNodeAttribute(newNodeId, 'y', newY);
    });
  }

  function mountOnce(initialData){
    const container = document.getElementById('container');
    GRAPH = new GraphologyGraph({ type:'undirected', multi:true });
    
    // 초기 그래프는 원형 배치 사용
    const nodes = initialData.nodes || [];
    const N = nodes.length || 1;
    nodes.forEach((n, i) => {
      n._initialX = Math.cos(2*Math.PI*i/N)*120;
      n._initialY = Math.sin(2*Math.PI*i/N)*120;
    });
    // 오버레이 초기화 제거됨

    RENDERER = new SigmaCtor(GRAPH, container, {
       renderLabels: true,
    //   labelDensity: 0.9,
    //   labelSize: 10,
    //   labelColor: { color: 'data(labelColor)' },
      edgeColor:'data',
      color: 'data',
      enableEdgeHoverEvents: true,
      edgeHoverPrecision: 80,
      hideEdgesOnMove: false,            // 계속 보여주고 오버레이만 재그림
      enableEdgeClickEvents: true,
      edgeReducer: (edge, data) => {
        // 모든 간선을 단일 엣지로 통일 처리
        const cnt = data.parallelCount || 1;
        let w = Math.max(2.5, (data.size || 3) * 1.8);
        const hovered = GRAPH.getEdgeAttribute(edge, '__hover__');
        if (hovered) w *= 1.15;
        
        // colorHex가 명시적으로 설정되어 있으면 그것을 사용 (하이라이팅 시)
        // 그렇지 않으면 멀티 트레이트는 검정색, 단일 트레이트는 기본 색상
        let color = data.colorHex;
        if (!isHighlighted) {
          // 하이라이팅 중이 아닐 때만 기본 색상 규칙 적용
          color = (cnt > 1) ? '#000000' : (data.colorHex || '#9aa0a6');
        } else {
          // 하이라이팅 중일 때는 colorHex 그대로 사용
          color = data.colorHex || '#9aa0a6';
          // 디버깅: 멀티 트레이트 엣지 색상 확인
          if (cnt > 1) {
            console.log(`Multi-trait edge [${edge}]: isHighlighted=${isHighlighted}, colorHex=${data.colorHex}, final color=${color}`);
          }
        }
        return { ...data, color, size: w };
      },
    });

    // 캡터 hover 안정화
    const captor = RENDERER.getMouseCaptor();
    let hoverDisabled = false;
    const setHover = (on) => {
      if (hoverDisabled === !on) return;
      hoverDisabled = !on;
      RENDERER.setSetting('enableEdgeHoverEvents', on);
    };
    captor.on('mousedown', () => setHover(false));
    captor.on('drag',     () => setHover(false));
    captor.on('mouseup',  () => setHover(true));
    // 카메라 업데이트 시 오버레이 렌더링 제거됨

    // 이벤트(노드/엣지)
    RENDERER.on('enterNode', ({ node }) => {
      hoveredNode = node;
      
      // 커서 변경
      document.body.classList.add('hovering-node');
      
      const attrs = GRAPH.getNodeAttributes(node);
      
      // 노드의 추가 정보를 백엔드 데이터에서 찾기
      let nodeDetails = null;
      if (DATA && DATA.nodes) {
        nodeDetails = DATA.nodes.find(n => n.id === node);
      }
      
      const payload = {
        id: node, 
        label: attrs.label || '', 
        ropeColor: attrs.color,
        ropeCount: nodeDetails ? nodeDetails.ropes?.length || 0 : 0,
        traitCount: nodeDetails ? nodeDetails.traits?.length || 0 : 0,
        ropeName: nodeDetails ? nodeDetails.ropeName || 'Unknown' : 'Unknown',
        ropeId: nodeDetails ? nodeDetails.ropeId || 0 : 0,
        ropes: nodeDetails ? nodeDetails.ropes || [] : [],
        traits: nodeDetails ? nodeDetails.traits || [] : []
      };
      
      console.log('Node hover payload:', payload);
      console.log('NodeDetails:', nodeDetails);
      
      window.parent && window.parent.postMessage({ type: 'node-hover', payload}, '*');
    });
    
    RENDERER.on('leaveNode', () => {
      hoveredNode = null;
      
      // 커서 복원
      document.body.classList.remove('hovering-node');
      
      window.parent && window.parent.postMessage({ type: 'node-hover', payload: null }, '*');
    });

    RENDERER.on('enterEdge', ({ edge }) => {
      GRAPH.setEdgeAttribute(edge, '__hover__', true);
      const a = GRAPH.getEdgeAttributes(edge);
      
      // 멀티 엣지인지 확인하고 모든 관련 트레이트 정보 수집
      const parallelCount = a.parallelCount || 1;
      if (parallelCount > 1) {
        // 같은 노드 쌍의 모든 엣지 찾기
        const src = GRAPH.source(edge);
        const dst = GRAPH.target(edge);
        const allTraits = [];
        
        GRAPH.forEachEdge((edgeKey, attrs) => {
          const eSrc = GRAPH.source(edgeKey);
          const eDst = GRAPH.target(edgeKey);
          
          // 같은 노드 쌍인지 확인 (양방향 고려)
          if ((eSrc === src && eDst === dst) || (eSrc === dst && eDst === src)) {
            allTraits.push({
              traitCode: attrs.traitCode || 0,
              traitName: attrs.traitName || '',
              traitId: attrs.traitId || 0,
              lastSeen: attrs.lastSeen || 0
            });
          }
        });
        
        // 멀티 트레이트 정보 전송
        window.parent && window.parent.postMessage({ type:'edge-hover', payload:{
          id: edge, 
          isMultiTrait: true,
          traits: allTraits,
          totalTraits: allTraits.length
        }}, '*');
      } else {
        // 단일 트레이트 엣지
        window.parent && window.parent.postMessage({ type:'edge-hover', payload:{
          id: edge, 
          traitCode: a.traitCode||0, 
          traitName: a.traitName||'', 
          traitId: a.traitId||0, 
          lastSeen: a.lastSeen||0,
          isMultiTrait: false
        }}, '*');
      }
    });
    RENDERER.on('leaveEdge', ({ edge }) => {
      GRAPH.removeEdgeAttribute(edge, '__hover__');
      window.parent && window.parent.postMessage({ type:'edge-hover', payload:null }, '*');
    });
    // 노드 드래그 기능
    let draggedNode = null;
    let isDragging = false;
    let dragStartTime = 0;
    
    // 클릭 vs 드래그 구분을 위한 변수들
    let dragStartX = 0;
    let dragStartY = 0;
    const DRAG_THRESHOLD = 5; // 5픽셀 이상 움직이면 드래그로 간주

    RENDERER.on('downNode', ({ node, captor, event }) => {
      draggedNode = node;
      isDragging = false;
      dragStartTime = Date.now();
      
      // 드래그 시작 위치 기록
      dragStartX = event.original.clientX;
      dragStartY = event.original.clientY;
      
      // 노드 드래그 시 화면 이동 방지
      captor.isDragging = true; // Sigma.js에 드래그 중임을 알림
      
      // 카메라 완전 비활성화
      RENDERER.getCamera().disable();
      
      // 드래그 중 다른 이벤트들과 카메라 이동 비활성화
      RENDERER.setSetting('enableEdgeHoverEvents', false);
      
      // 이벤트 전파 중단
      event.preventSigmaDefault();
      event.original.preventDefault();
      event.original.stopPropagation();
    });
    
    RENDERER.getMouseCaptor().on('mousemove', (event) => {
      if (draggedNode) {
        // 드래그 거리 계산
        const currentX = event.original.clientX;
        const currentY = event.original.clientY;
        const dragDistance = Math.sqrt(
          Math.pow(currentX - dragStartX, 2) + Math.pow(currentY - dragStartY, 2)
        );
        
        // 임계값을 넘었을 때만 실제 드래그 시작
        if (dragDistance > DRAG_THRESHOLD) {
          isDragging = true;
          
          // 드래그 시작 시 커서 변경 (여기서 처음 변경)
          if (!document.body.classList.contains('dragging-node')) {
            document.body.classList.remove('hovering-node');
            document.body.classList.add('dragging-node');
          }
          
          // 마우스 좌표를 그래프 좌표로 변환
          const pos = RENDERER.viewportToGraph(event);
          
          // 노드 위치 업데이트
          GRAPH.setNodeAttribute(draggedNode, 'x', pos.x);
          GRAPH.setNodeAttribute(draggedNode, 'y', pos.y);
          
          // 렌더러 새로고침 (엣지가 자동으로 따라옴)
          RENDERER.refresh();
        }
        
        // 이벤트 전파 중단 (화면 이동 방지)
        event.preventSigmaDefault();
        event.original.preventDefault();
        event.original.stopPropagation();
      }
    });
    
    RENDERER.getMouseCaptor().on('mouseup', () => {
      if (draggedNode) {
        const captor = RENDERER.getMouseCaptor();
        captor.isDragging = false; // 드래그 상태 해제
        
        // 카메라 다시 활성화
        RENDERER.getCamera().enable();
        
        // 클릭 vs 드래그 구분
        if (!isDragging) {
          // 클릭으로 판단 - 확장 요청
          console.log(`Node clicked (not dragged): ${draggedNode}`);
          window.parent && window.parent.postMessage({ type:'node-click', payload:{ id: draggedNode }}, '*');
        } else {
          // 드래그로 판단 - 노드 이동 완료
          console.log(`Node dragged: ${draggedNode}`);
        }
        
        // 상태 초기화
        document.body.classList.remove('dragging-node');
        document.body.classList.remove('hovering-node');
        
        draggedNode = null;
        isDragging = false;
        
        // 이벤트 재활성화
        setTimeout(() => {
          RENDERER.setSetting('enableEdgeHoverEvents', true);
        }, 100);
      }
    });

    // 최초 데이터 주입
    addDataToGraph(initialData);
    updateHud();

    // 디버깅 핸들
    window.__GRAPH = GRAPH;
    window.__RENDERER = RENDERER;
  }

  function updateHud(){
    document.getElementById('ncount').textContent = String(GRAPH.order);
    document.getElementById('ecount').textContent = String(GRAPH.size);
  }

  // 오버레이 렌더링 함수들 제거됨

  // ===== 트레이트 하이라이팅 =====
  let originalNodeColors = new Map();
  let originalEdgeColors = new Map();
  
  function restoreOriginalColors() {
    if (!GRAPH || !RENDERER) return;
    
    console.log('Restoring original colors...');
    
    // 원본 색상이 저장되어 있다면 복원
    if (originalNodeColors.size > 0) {
      originalNodeColors.forEach((color, node) => {
        if (GRAPH.hasNode(node)) {
          GRAPH.setNodeAttribute(node, 'color', color);
        }
      });
    }
    
    if (originalEdgeColors.size > 0) {
      originalEdgeColors.forEach((color, edge) => {
        if (GRAPH.hasEdge(edge)) {
          GRAPH.setEdgeAttribute(edge, 'colorHex', color);
        }
      });
    }
    
    // 원본 색상 맵 초기화
    originalNodeColors.clear();
    originalEdgeColors.clear();
    isHighlighted = false;
    
    RENDERER.refresh();
  }
  
  function highlightTraitInGraph(traitCode, highlightColor) {
    if (!GRAPH || !RENDERER) return;
    
    // 트레이트 하이라이팅 상태 업데이트
    if (traitCode === null) {
      currentTraitHighlight = null;
    } else {
      const processedColor = parseColorToHex(highlightColor);
      currentTraitHighlight = {code: traitCode, color: processedColor};
      console.log(`Highlighting trait: ${traitCode} with color: ${highlightColor} -> ${processedColor}`);
    }
    
    // 통합 하이라이팅 적용
    applyHighlighting();
  }
  
  function highlightRuleInGraph(ruleId, highlightColor) {
    if (!GRAPH || !RENDERER) return;
    
    // 룰 하이라이팅 상태 업데이트
    if (ruleId === null) {
      currentRuleHighlight = null;
    } else {
      const processedColor = parseColorToHex(highlightColor);
      currentRuleHighlight = {id: ruleId, color: processedColor};
      console.log(`Highlighting rule: ${ruleId} with color: ${highlightColor} -> ${processedColor}`);
    }
    
    // 통합 하이라이팅 적용
    applyHighlighting();
  }
  
  function highlightPolyTraitInGraph(polyTraitCode, highlightColor, polyTraitData) {
    if (!GRAPH || !RENDERER) return;
    
    console.log('=== highlightPolyTraitInGraph called ===');
    console.log('polyTraitCode:', polyTraitCode);
    console.log('highlightColor:', highlightColor);
    console.log('polyTraitData:', polyTraitData);
    
    // PolyTrait 하이라이팅 상태 업데이트
    if (polyTraitCode === null) {
      console.log('Clearing PolyTrait highlight');
      currentPolyTraitHighlight = null;
    } else {
      const processedColor = parseColorToHex(highlightColor);
      currentPolyTraitHighlight = {
        code: polyTraitCode, 
        color: processedColor,
        data: polyTraitData
      };
      console.log(`Setting PolyTrait highlight: ${polyTraitCode} with color: ${highlightColor} -> ${processedColor}`);
    }
    
    console.log('Current highlight state:', {
      trait: currentTraitHighlight?.code || null,
      rule: currentRuleHighlight?.id || null,
      polyTrait: currentPolyTraitHighlight?.code || null
    });
    
    // 통합 하이라이팅 적용
    applyHighlighting();
  }

  // 통합 하이라이팅 적용 함수
  function applyHighlighting() {
    if (!GRAPH || !RENDERER) return;

    console.log('=== applyHighlighting called ===');
    console.log('Highlight states:', {
      trait: currentTraitHighlight?.code || null,
      rule: currentRuleHighlight?.id || null,  
      polyTrait: currentPolyTraitHighlight?.code || null
    });

    // 하이라이팅이 없으면 원상복구
    if (!currentTraitHighlight && !currentRuleHighlight && !currentPolyTraitHighlight) {
      console.log('No highlighting active, restoring original colors');
      isHighlighted = false;
      restoreOriginalColors();
      return;
    }

    // 원본 색상 저장 (처음에만)
    if (!isHighlighted) {
      GRAPH.forEachNode((node) => {
        originalNodeColors.set(node, GRAPH.getNodeAttribute(node, 'color'));
      });
      
      GRAPH.forEachEdge((edge) => {
        const attrs = GRAPH.getEdgeAttributes(edge);
        const cnt = attrs.parallelCount || 1;
        
        if (cnt > 1) {
          originalEdgeColors.set(edge, '#000000');
        } else {
          originalEdgeColors.set(edge, attrs.colorHex);
        }
      });
    }

    isHighlighted = true;

    console.log('Setting all elements to gray...');
    // 먼저 모든 요소를 회색으로 변경
    let nodeCount = 0, edgeCount = 0;
    GRAPH.forEachNode((node) => {
      GRAPH.setNodeAttribute(node, 'color', '#dddddd');
      nodeCount++;
    });
    
    GRAPH.forEachEdge((edge) => {
      const attrs = GRAPH.getEdgeAttributes(edge);
      const cnt = attrs.parallelCount || 1;
      GRAPH.setEdgeAttribute(edge, 'colorHex', '#dddddd');
      edgeCount++;
    });
    
    console.log(`Set ${nodeCount} nodes and ${edgeCount} edges to gray`);

    // 하이라이팅된 요소들 수집
    const highlightedNodes = new Set();
    console.log('Starting to collect highlighted elements...');
    
    // 트레이트 하이라이팅 처리
    if (currentTraitHighlight) {
      const traitCode = currentTraitHighlight.code;
      const processedColor = currentTraitHighlight.color;
      
      if (traitCode === 'multi') {
        // Multi-Trait 하이라이팅
        GRAPH.forEachEdge((edge, attrs) => {
          const cnt = attrs.parallelCount || 1;
          if (cnt > 1) {
            GRAPH.setEdgeAttribute(edge, 'colorHex', '#000000');
            const src = GRAPH.source(edge);
            const dst = GRAPH.target(edge);
            highlightedNodes.add(src);
            highlightedNodes.add(dst);
          }
        });
      } else {
        // 특정 트레이트 하이라이팅
        const edgePairs = new Map();
        
        GRAPH.forEachEdge((edge) => {
          const src = GRAPH.source(edge);
          const dst = GRAPH.target(edge);
          const key = src < dst ? `${src}|${dst}` : `${dst}|${src}`;
          if (!edgePairs.has(key)) {
            edgePairs.set(key, []);
          }
          edgePairs.get(key).push(edge);
        });
        
        edgePairs.forEach((edges) => {
          let hasTargetTrait = false;
          edges.forEach(edge => {
            const attrs = GRAPH.getEdgeAttributes(edge);
            if (String(attrs.traitCode) === String(traitCode)) {
              hasTargetTrait = true;
            }
          });
          
          if (hasTargetTrait) {
            edges.forEach(edge => {
              GRAPH.setEdgeAttribute(edge, 'colorHex', processedColor);
              const src = GRAPH.source(edge);
              const dst = GRAPH.target(edge);
              highlightedNodes.add(src);
              highlightedNodes.add(dst);
            });
          }
        });
      }
    }

    // 룰 하이라이팅 처리 (노드) - 노드의 모든 Rule 확인
    if (currentRuleHighlight) {
      const ruleId = currentRuleHighlight.id;
      const processedColor = currentRuleHighlight.color;
      
      console.log(`Processing rule highlighting for Rule ID: ${ruleId}`);
      
      if (DATA && DATA.nodes) {
        let checkedNodes = 0;
        let matchedNodes = 0;
        
        DATA.nodes.forEach(nodeData => {
          checkedNodes++;
          
          if (nodeData.traits && Array.isArray(nodeData.traits)) {
            // 노드의 모든 traits에서 ruleCode가 일치하는 것이 있는지 확인
            let hasTargetRule = false;
            
            nodeData.traits.forEach(trait => {
              const nodeRuleCode = trait.ruleCode;
              if (nodeRuleCode && String(nodeRuleCode) === String(ruleId)) {
                hasTargetRule = true;
                console.log(`Node ${nodeData.id} has matching rule: trait ${trait.traitCode} with ruleCode ${nodeRuleCode}`);
              }
            });
            
            if (hasTargetRule && GRAPH.hasNode(nodeData.id)) {
              highlightedNodes.add(nodeData.id);
              matchedNodes++;
              console.log(`Added node ${nodeData.id} to highlighted nodes`);
            }
          } else {
            console.log(`Node ${nodeData.id} has no traits or traits is not array:`, nodeData.traits);
          }
        });
        
        console.log(`Rule highlighting summary: checked ${checkedNodes} nodes, matched ${matchedNodes} nodes for rule ${ruleId}`);
      } else {
        console.log('No DATA or DATA.nodes available for rule highlighting');
      }
    }

    // PolyTrait 하이라이팅 처리 (기존 Trait 하이라이팅 로직을 OR 조건으로 재활용)
    if (currentPolyTraitHighlight) {
      const polyTraitCode = currentPolyTraitHighlight.code;
      const processedColor = currentPolyTraitHighlight.color;
      const polyTraitData = currentPolyTraitHighlight.data;
      
      console.log(`Processing PolyTrait highlight: ${polyTraitCode}`);
      console.log('Using passed polyTraitData:', polyTraitData);
      
      // PolyTrait에 포함된 Trait들 가져오기 (메시지로 전달받은 데이터 사용)
      let polyTraitTraits = [];
      
      console.log('polyTraitData type:', typeof polyTraitData);
      console.log('polyTraitData keys:', polyTraitData ? Object.keys(polyTraitData) : 'no data');
      console.log(`Looking for polyTraitCode: ${polyTraitCode} (type: ${typeof polyTraitCode})`);
      
      if (polyTraitData && polyTraitData[polyTraitCode]) {
        const polyData = polyTraitData[polyTraitCode];
        console.log(`PolyTrait ${polyTraitCode} data from message:`, polyData);
        
        polyTraitTraits = polyData.Traits || polyData.traits || [];
        console.log(`PolyTrait ${polyTraitCode} contains traits:`, polyTraitTraits);
      } else {
        console.warn(`PolyTrait ${polyTraitCode} not found in passed data`);
        console.warn('Available PolyTrait codes:', polyTraitData ? Object.keys(polyTraitData) : 'no data');
        console.warn('Exact comparison results:');
        if (polyTraitData) {
          Object.keys(polyTraitData).forEach(key => {
            console.warn(`  "${key}" (type: ${typeof key}) === "${polyTraitCode}" (type: ${typeof polyTraitCode}): ${key === polyTraitCode}`);
            console.warn(`  "${key}" == "${polyTraitCode}": ${key == polyTraitCode}`);
          });
        }
      }
      
      if (polyTraitTraits.length === 0) {
        console.warn(`No traits found for PolyTrait ${polyTraitCode}, highlighting all edges`);
        // 폴백: 모든 엣지 하이라이팅
        GRAPH.forEachEdge((edge) => {
          GRAPH.setEdgeAttribute(edge, 'colorHex', processedColor);
          const src = GRAPH.source(edge);
          const dst = GRAPH.target(edge);
          highlightedNodes.add(src);
          highlightedNodes.add(dst);
        });
      } else {
        // 기존 Trait 하이라이팅 로직을 재활용 (OR 조건으로)
        const edgePairs = new Map();
        
        GRAPH.forEachEdge((edge) => {
          const src = GRAPH.source(edge);
          const dst = GRAPH.target(edge);
          const key = src < dst ? `${src}|${dst}` : `${dst}|${src}`;
          if (!edgePairs.has(key)) {
            edgePairs.set(key, []);
          }
          edgePairs.get(key).push(edge);
        });
        
        edgePairs.forEach((edges) => {
          let hasPolyTraitMatch = false;
          
          // 각 엣지에 대해 PolyTrait에 포함된 Trait 중 하나라도 일치하는지 확인 (OR 조건)
          edges.forEach(edge => {
            const attrs = GRAPH.getEdgeAttributes(edge);
            const edgeTraitCode = attrs.traitCode;
            
            // PolyTrait에 포함된 Trait 중 하나라도 일치하면 true
            if (polyTraitTraits.some(traitCode => String(edgeTraitCode) === String(traitCode))) {
              hasPolyTraitMatch = true;
              console.log(`Edge ${edge} matches PolyTrait (trait: ${edgeTraitCode})`);
            }
          });
          
          // PolyTrait에 일치하는 Trait가 있으면 해당 엣지 그룹 전체 하이라이팅
          if (hasPolyTraitMatch) {
            edges.forEach(edge => {
              GRAPH.setEdgeAttribute(edge, 'colorHex', processedColor);
              const src = GRAPH.source(edge);
              const dst = GRAPH.target(edge);
              highlightedNodes.add(src);
              highlightedNodes.add(dst);
            });
          }
        });
      }
      
      console.log('Total highlighted nodes for PolyTrait:', highlightedNodes.size);
    }

    // 트레이트 하이라이팅 색상 적용
    if (currentTraitHighlight) {
      highlightedNodes.forEach(node => {
        GRAPH.setNodeAttribute(node, 'color', currentTraitHighlight.color);
      });
    }
    
    // 룰 하이라이팅 색상 적용 (덮어쓰기) - 모든 Rule 확인
    if (currentRuleHighlight) {
      const ruleId = currentRuleHighlight.id;
      const processedColor = currentRuleHighlight.color;
      
      console.log(`Applying rule highlighting colors for Rule ID: ${ruleId} with color: ${processedColor}`);
      
      if (DATA && DATA.nodes) {
        let coloredNodes = 0;
        
        DATA.nodes.forEach(nodeData => {
          if (nodeData.traits && Array.isArray(nodeData.traits)) {
            // 노드의 모든 traits에서 ruleCode가 일치하는 것이 있는지 확인
            let hasTargetRule = false;
            
            nodeData.traits.forEach(trait => {
              const nodeRuleCode = trait.ruleCode;
              if (nodeRuleCode && String(nodeRuleCode) === String(ruleId)) {
                hasTargetRule = true;
              }
            });
            
            if (hasTargetRule && GRAPH.hasNode(nodeData.id)) {
              GRAPH.setNodeAttribute(nodeData.id, 'color', processedColor);
              coloredNodes++;
              console.log(`Applied color ${processedColor} to node ${nodeData.id} for rule ${ruleId}`);
            }
          }
        });
        
        console.log(`Applied rule highlighting color to ${coloredNodes} nodes for rule ${ruleId}`);
      }
    }
    
    // PolyTrait 하이라이팅 색상 적용 (최우선)
    if (currentPolyTraitHighlight) {
      const polyTraitCode = currentPolyTraitHighlight.code;
      const processedColor = currentPolyTraitHighlight.color;
      
      console.log('Applying PolyTrait colors:', {polyTraitCode, processedColor});
      console.log('Nodes to color:', highlightedNodes.size);
      
      // 하이라이팅된 노드들에만 색상 적용
      highlightedNodes.forEach(nodeId => {
        if (GRAPH.hasNode(nodeId)) {
          GRAPH.setNodeAttribute(nodeId, 'color', processedColor);
          console.log(`Applied color ${processedColor} to node ${nodeId}`);
        }
      });
    }

    RENDERER.refresh();
  }
  
  function clearHighlightInGraph() {
    currentTraitHighlight = null;
    currentRuleHighlight = null;
    currentPolyTraitHighlight = null;
    restoreOriginalColors();
  }



  // 그래프 완전 초기화 함수 (검색용)
  function resetAndLoadGraph(newData) {
    console.log('=== RESETTING GRAPH ===');
    console.log('New graph data:', {
      nodes: newData.nodes?.length || 0,
      edges: newData.edges?.length || 0,
      startNode: newData.meta?.startNode
    });
    
    if (!GRAPH || !RENDERER) {
      console.log('No existing graph, using mountOnce');
      return mountOnce(newData);
    }
    
    // 기존 그래프 완전 클리어
    GRAPH.clear();
    console.log('Graph cleared');
    
    // 새 데이터로 그래프 재구성
    DATA = newData;
    TRAIT_PALETTE = buildTraitPaletteFromLegend();
    
    const nodes = newData.nodes || [];
    const edges = newData.edges || [];
    const N = nodes.length || 1;
    
    // 노드들을 원형으로 배치 (초기 로딩처럼)
    nodes.forEach((n, i) => {
      const x = Math.cos(2*Math.PI*i/N)*120;
      const y = Math.sin(2*Math.PI*i/N)*120;
      
      GRAPH.addNode(n.id, {
        label: n.label || n.id,
        size: Math.max(4, Math.min(16, n.size||8)),
        color: '#222222',
        labelColor: '#ffffff',
        x: x,
        y: y
      });
    });
    
    // 엣지 추가
    const seen = new Set();
    edges.forEach((e)=>{
      if (seen.has(e.id)) return; seen.add(e.id);
      const src = e.source, dst = e.target;
      
      // 노드가 없으면 기본 노드 추가
      if (!GRAPH.hasNode(src)) GRAPH.addNode(src, { label: src, size: 6, color: '#222222', labelColor: '#ffffff', x: 0, y: 0 });
      if (!GRAPH.hasNode(dst)) GRAPH.addNode(dst, { label: dst, size: 6, color: '#222222', labelColor: '#ffffff', x: 0, y: 0 });

      const tc = Number(e.traitCode) || 0;
      const hex = parseColorToHex(e.color || (traitColorFromLegend(tc, null) || genTraitColor(tc)));

      const attrs = {
        size: Math.max(3, Math.min(9, (e.weight || 3))),
        colorHex: hex,
        traitCode: e.traitCode, traitName: e.traitName, traitId: e.traitId, lastSeen: e.lastSeen||0,
        pair: e.pair || [src, dst].sort().join('|'),
        parallelIndex: (typeof e.parallelIndex === 'number') ? e.parallelIndex : 0,
        parallelCount: (typeof e.parallelCount === 'number' && e.parallelCount>0) ? e.parallelCount : 1
      };

      GRAPH.addEdgeWithKey(e.id, src, dst, attrs);
    });
    
    console.log('New graph loaded:', {
      nodes: GRAPH.order,
      edges: GRAPH.size
    });
    
    // 렌더러 새로고침
    RENDERER.refresh();
  }

  // ===== Messaging =====
  window.addEventListener('message', (ev)=>{
    const msg = ev.data||{};
    console.log('=== FRAME RECEIVED MESSAGE ===');
    console.log('Message type:', msg.type);
    console.log('Message payload nodes:', msg.payload?.nodes?.length || 0);
    console.log('Message payload edges:', msg.payload?.edges?.length || 0);
    
    if (msg.type==='load-graph'){
      try {
        if (RENDERER === null) {
          // 최초 로딩
          mountOnce(msg.payload);
        } else {
          // 검색 등으로 인한 그래프 완전 교체
          resetAndLoadGraph(msg.payload);
        }
        window.parent && window.parent.postMessage({type:'child-ready', payload:{ok:true}}, '*');
      } catch(e){
        console.error('Load graph error:', e);
        window.parent && window.parent.postMessage({type:'child-ready', payload:{ok:false, error:String(e)}}, '*');
      }
    } else if (msg.type==='apply-graph'){
      // 렌더러/그래프 kill 없이 증분 반영만
      addDataToGraph(msg.payload);
      updateHud();
    } else if (msg.type==='highlight-trait'){
      // 트레이트 하이라이팅
      const {traitCode, color} = msg.payload;
      highlightTraitInGraph(traitCode, color);
    } else if (msg.type==='highlight-rule'){
      // Rule 하이라이팅
      const {ruleId, color} = msg.payload;
      highlightRuleInGraph(ruleId, color);
    } else if (msg.type==='highlight-polytrait'){
      // PolyTrait 하이라이팅
      const {polyTraitCode, color, polyTraitData} = msg.payload;
      console.log('Message handler polyTraitData:', polyTraitData);
      highlightPolyTraitInGraph(polyTraitCode, color, polyTraitData);
    } else if (msg.type==='clear-highlight'){
      // 하이라이팅 해제
      clearHighlightInGraph();
    }
  });

  // 초기 준비 신호
  window.parent && window.parent.postMessage({type:'child-mounted'}, '*');
})();
</script>
</body></html>
