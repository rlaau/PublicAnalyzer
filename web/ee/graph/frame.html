<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Rope Graph Frame</title>
  <style>
    html,body{
      height:100%; margin:0;
      overflow:hidden; scrollbar-gutter: stable both-edges; overscroll-behavior:none;
    }
    #container{position:absolute;inset:0;overflow:hidden;touch-action:none;user-select:none}
    canvas{display:block}
    #hud{
      position:absolute;top:10px;left:10px;z-index:10;
      background:rgba(255,255,255,.92);padding:8px 10px;border-radius:10px;
      font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Noto Sans,Arial;
      box-shadow:0 2px 10px rgba(0,0,0,.08)
    }
    #hud code{padding:2px 6px;background:#eee;border-radius:6px}
  </style>
  <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.min.js"></script>
  <script src="https://unpkg.com/sigma@2.4.0/build/sigma.min.js"></script>
</head>
<body>
  <div id="hud"><strong>Rope Graph</strong>
    <div>nodes: <code id="ncount">0</code> | edges: <code id="ecount">0</code></div>
  </div>
  <div id="container"></div>

<script>
(function(){
  const SigmaCtor = (window && (window.Sigma || (window.sigma && window.sigma.Sigma))) || null;
  const GraphologyGraph = (window && window.graphology && window.graphology.Graph) ? window.graphology.Graph : null;

  let GRAPH = null, RENDERER = null, DATA = null;
  let TRAIT_PALETTE = {};

  // --- Colors ---
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function hslToHex(h, s, l){
    h = ((h%360)+360)%360; s = clamp01(s/100); l = clamp01(l/100);
    const c = (1 - Math.abs(2*l - 1)) * s, hp = h/60, x = c*(1 - Math.abs((hp%2)-1));
    let r=0,g=0,b=0;
    if (0<=hp && hp<1){ r=c; g=x; } else if (1<=hp && hp<2){ r=x; g=c; }
    else if (2<=hp && hp<3){ g=c; b=x; } else if (3<=hp && hp<4){ g=x; b=c; }
    else if (4<=hp && hp<5){ r=x; b=c; } else if (5<=hp && hp<6){ r=c; b=x; }
    const m = l - c/2; r = Math.round((r+m)*255); g = Math.round((g+m)*255); b = Math.round((b+m)*255);
    const toHex=n=>n.toString(16).padStart(2,'0'); return '#'+toHex(r)+toHex(g)+toHex(b);
  }
  function parseColorToHex(c){
    if (!c) return '#9aa0a6';
    if (c[0] === '#') return c;
    const s = String(c).trim();
    let m = /^hsl\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%\s*\)$/i.exec(s);
    if (m) return hslToHex(parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]));
    m = /^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i.exec(s);
    if (m){
      const r = Math.max(0, Math.min(255, parseInt(m[1],10)));
      const g = Math.max(0, Math.min(255, parseInt(m[2],10)));
      const b = Math.max(0, Math.min(255, parseInt(m[3],10)));
      const toHex=n=>n.toString(16).padStart(2,'0'); return '#'+toHex(r)+toHex(g)+toHex(b);
    }
    return '#9aa0a6';
  }
  function buildTraitPaletteFromLegend() {
    const pal = {};
    try {
      const L = DATA && DATA.legend && DATA.legend.traits ? DATA.legend.traits : {};
      Object.keys(L).forEach(k=>{
        const key = Number(k); const item = L[k] || {};
        if (key === 0 && !item.color) return;
        pal[key] = parseColorToHex(item.color || '#9aa0a6');
      });
    } catch (_){}
    return pal;
  }
  function traitColorFromLegend(tc, fallback) {
    const c = TRAIT_PALETTE[tc];
    return c || (fallback ? parseColorToHex(fallback) : null);
  }
  function genTraitColor(code){
    const h = (code * 89 + 180) % 360;
    const s = 65 + (code % 4) * 8;
    const l = 40 + (code % 5) * 5;
    return hslToHex(h, s, l);
  }

  function buildGraphFromData(data){
    DATA = data;
    TRAIT_PALETTE = buildTraitPaletteFromLegend();

    const G = new GraphologyGraph({ type:'undirected', multi:true });

    const NODE_COLOR = '#222222';
    const NODE_LABEL = '#ffffff';
    const N = (data.nodes||[]).length || 1;
    (data.nodes||[]).forEach((n,i)=>{
      if (!G.hasNode(n.id)) G.addNode(n.id, {
        label: n.label || n.id,
        size: Math.max(4, Math.min(16, n.size||8)),
        color: NODE_COLOR,
        labelColor: NODE_LABEL,
        x: Math.cos(2*Math.PI*i/N)*120,
        y: Math.sin(2*Math.PI*i/N)*120
      });
    });

    const pairCount = Object.create(null);
    const eseen = new Set();

    (data.edges||[]).forEach((e)=>{
      if (eseen.has(e.id)) return; eseen.add(e.id);
      const src = e.source, dst = e.target;
      if (!G.hasNode(src)) G.addNode(src, { label: src, size: 6, color: NODE_COLOR, labelColor: NODE_LABEL });
      if (!G.hasNode(dst)) G.addNode(dst, { label: dst, size: 6, color: NODE_COLOR, labelColor: NODE_LABEL });

      const lo = src < dst ? src : dst;
      const hi = src < dst ? dst : src;
      const key = lo + '|' + hi;
      const k = (pairCount[key] = (pairCount[key] || 0) + 1);

      const width = Math.max(1, Math.min(5, (e.weight||1) * (1 + (k-1)*0.2)));
      const tc = Number(e.traitCode) || 0;

      const hex = parseColorToHex(
        e.color || (traitColorFromLegend(tc, null) || genTraitColor(tc))
      );

      G.addEdgeWithKey(e.id, src, dst, {
        size: width,
        colorHex: hex,
        traitCode: e.traitCode, traitName: e.traitName, traitId: e.traitId, lastSeen: e.lastSeen||0
      });
    });

    return G;
  }

  function mount(G){
    const container = document.getElementById('container');
    if (RENDERER) { RENDERER.kill(); RENDERER = null; }
    GRAPH = G;

    const BIG_EDGE_THRESHOLD = 4000;
    const hideOnMove = GRAPH.size > BIG_EDGE_THRESHOLD;
    RENDERER = new SigmaCtor(GRAPH, container, {
      renderLabels: true,
      labelDensity: 0.85,
      labelSize: 10,
      labelColor: { color: 'data(labelColor)' },
      edgeColor:'data',
      color: 'data',
      enableEdgeHoverEvents: true,
      edgeHoverPrecision: 80,
      hideEdgesOnMove: hideOnMove,
      enableEdgeClickEvents: false,
      edgeReducer: (edge, data) => {
        let w = Math.max(4, Math.min(7, data.size || 2));
        if (data.hovered || GRAPH.getEdgeAttribute(edge, '__hover__')) w = Math.max(w, 7);
        return { ...data, color: data.colorHex || '#9aa0a6', size: w };
      },
    });

    const captor = RENDERER.getMouseCaptor();
    let hoverDisabled = false;
    const setHover = (on) => {
      if (hoverDisabled === !on) return;
      hoverDisabled = !on;
      RENDERER.setSetting('enableEdgeHoverEvents', on);
    };
    captor.on('mousedown', () => setHover(false));
    captor.on('drag',     () => setHover(false));
    captor.on('mouseup',  () => setHover(true));
    RENDERER.getCamera().on('updated', () => {
      clearTimeout(RENDERER.__hoverTimer);
      RENDERER.__hoverTimer = setTimeout(()=>setHover(true), 120);
    });

    document.getElementById('ncount').textContent = String(GRAPH.order);
    document.getElementById('ecount').textContent = String(GRAPH.size);

    RENDERER.on('enterNode', ({ node }) => {
      const attrs = GRAPH.getNodeAttributes(node);
      const payload = { id: node, label: attrs.label || '', ropeColor: attrs.color };
      window.parent && window.parent.postMessage({ type: 'node-hover', payload }, '*');
    });
    RENDERER.on('leaveNode', () => {
      window.parent && window.parent.postMessage({ type: 'node-hover', payload: null }, '*');
    });
    RENDERER.on('enterEdge', ({ edge }) => {
      const a = GRAPH.getEdgeAttributes(edge);
      window.parent && window.parent.postMessage({ type:'edge-hover', payload:{
        id: edge, traitCode: a.traitCode||0, traitName: a.traitName||'', traitId: a.traitId||0, lastSeen: a.lastSeen||0
      }}, '*');
    });
    RENDERER.on('leaveEdge', () => {
      window.parent && window.parent.postMessage({ type:'edge-hover', payload:null }, '*');
    });
    RENDERER.on('clickNode', ({ node }) => {
      window.parent && window.parent.postMessage({ type:'node-click', payload:{ id: node }}, '*');
    });
  }

  window.addEventListener('message', (ev)=>{
    const msg = ev.data||{};
    if (msg.type==='load-graph'){
      try {
        const g=buildGraphFromData(msg.payload);
        mount(g);
        window.parent && window.parent.postMessage({type:'child-ready', payload:{ok:true}}, '*');
      } catch(e){
        window.parent && window.parent.postMessage({type:'child-ready', payload:{ok:false, error:String(e)}}, '*');
      }
    } else if (msg.type==='apply-graph'){
      const g = buildGraphFromData(msg.payload);
      mount(g);
    }
  });

  window.parent && window.parent.postMessage({type:'child-mounted'}, '*');
})();
</script>
</body></html>
